module DockerEngine
  module Models
    type spec =
      {
        endpoint_spec: DockerEngine::Spec::EndpointSpec,
        labels: ::Hash[Symbol, String],
        mode: DockerEngine::Spec::Mode,
        name: String,
        networks: ::Array[DockerEngine::Spec::Network],
        rollback_config: DockerEngine::Spec::RollbackConfig,
        task_template: DockerEngine::Spec::TaskTemplate,
        update_config: DockerEngine::Spec::UpdateConfig
      }

    class Spec < DockerEngine::Internal::Type::BaseModel
      attr_reader endpoint_spec: DockerEngine::Spec::EndpointSpec?

      def endpoint_spec=: (
        DockerEngine::Spec::EndpointSpec
      ) -> DockerEngine::Spec::EndpointSpec

      attr_reader labels: ::Hash[Symbol, String]?

      def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

      attr_reader mode: DockerEngine::Spec::Mode?

      def mode=: (DockerEngine::Spec::Mode) -> DockerEngine::Spec::Mode

      attr_reader name: String?

      def name=: (String) -> String

      attr_reader networks: ::Array[DockerEngine::Spec::Network]?

      def networks=: (
        ::Array[DockerEngine::Spec::Network]
      ) -> ::Array[DockerEngine::Spec::Network]

      attr_reader rollback_config: DockerEngine::Spec::RollbackConfig?

      def rollback_config=: (
        DockerEngine::Spec::RollbackConfig
      ) -> DockerEngine::Spec::RollbackConfig

      attr_reader task_template: DockerEngine::Spec::TaskTemplate?

      def task_template=: (
        DockerEngine::Spec::TaskTemplate
      ) -> DockerEngine::Spec::TaskTemplate

      attr_reader update_config: DockerEngine::Spec::UpdateConfig?

      def update_config=: (
        DockerEngine::Spec::UpdateConfig
      ) -> DockerEngine::Spec::UpdateConfig

      def initialize: (
        ?endpoint_spec: DockerEngine::Spec::EndpointSpec,
        ?labels: ::Hash[Symbol, String],
        ?mode: DockerEngine::Spec::Mode,
        ?name: String,
        ?networks: ::Array[DockerEngine::Spec::Network],
        ?rollback_config: DockerEngine::Spec::RollbackConfig,
        ?task_template: DockerEngine::Spec::TaskTemplate,
        ?update_config: DockerEngine::Spec::UpdateConfig
      ) -> void

      def to_hash: -> {
        endpoint_spec: DockerEngine::Spec::EndpointSpec,
        labels: ::Hash[Symbol, String],
        mode: DockerEngine::Spec::Mode,
        name: String,
        networks: ::Array[DockerEngine::Spec::Network],
        rollback_config: DockerEngine::Spec::RollbackConfig,
        task_template: DockerEngine::Spec::TaskTemplate,
        update_config: DockerEngine::Spec::UpdateConfig
      }

      type endpoint_spec =
        {
          mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        }

      class EndpointSpec < DockerEngine::Internal::Type::BaseModel
        attr_reader mode: DockerEngine::Models::Spec::EndpointSpec::mode?

        def mode=: (
          DockerEngine::Models::Spec::EndpointSpec::mode
        ) -> DockerEngine::Models::Spec::EndpointSpec::mode

        attr_reader ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]?

        def ports=: (
          ::Array[DockerEngine::Spec::EndpointSpec::Port]
        ) -> ::Array[DockerEngine::Spec::EndpointSpec::Port]

        def initialize: (
          ?mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ?ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        ) -> void

        def to_hash: -> {
          mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        }

        type mode = :vip | :dnsrr

        module Mode
          extend DockerEngine::Internal::Type::Enum

          VIP: :vip
          DNSRR: :dnsrr

          def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::mode]
        end

        type port =
          {
            name: String,
            protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            target_port: Integer
          }

        class Port < DockerEngine::Internal::Type::BaseModel
          attr_reader name: String?

          def name=: (String) -> String

          attr_reader protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol?

          def protocol=: (
            DockerEngine::Models::Spec::EndpointSpec::Port::protocol
          ) -> DockerEngine::Models::Spec::EndpointSpec::Port::protocol

          attr_reader published_port: Integer?

          def published_port=: (Integer) -> Integer

          attr_reader publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode?

          def publish_mode=: (
            DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode
          ) -> DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode

          attr_reader target_port: Integer?

          def target_port=: (Integer) -> Integer

          def initialize: (
            ?name: String,
            ?protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            ?published_port: Integer,
            ?publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            ?target_port: Integer
          ) -> void

          def to_hash: -> {
            name: String,
            protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            target_port: Integer
          }

          type protocol = :tcp | :udp | :sctp

          module Protocol
            extend DockerEngine::Internal::Type::Enum

            TCP: :tcp
            UDP: :udp
            SCTP: :sctp

            def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::Port::protocol]
          end

          type publish_mode = :ingress | :host

          module PublishMode
            extend DockerEngine::Internal::Type::Enum

            INGRESS: :ingress
            HOST: :host

            def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode]
          end
        end
      end

      type mode =
        {
          global: top,
          global_job: top,
          replicated: DockerEngine::Spec::Mode::Replicated,
          replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        }

      class Mode < DockerEngine::Internal::Type::BaseModel
        attr_reader global: top?

        def global=: (top) -> top

        attr_reader global_job: top?

        def global_job=: (top) -> top

        attr_reader replicated: DockerEngine::Spec::Mode::Replicated?

        def replicated=: (
          DockerEngine::Spec::Mode::Replicated
        ) -> DockerEngine::Spec::Mode::Replicated

        attr_reader replicated_job: DockerEngine::Spec::Mode::ReplicatedJob?

        def replicated_job=: (
          DockerEngine::Spec::Mode::ReplicatedJob
        ) -> DockerEngine::Spec::Mode::ReplicatedJob

        def initialize: (
          ?global: top,
          ?global_job: top,
          ?replicated: DockerEngine::Spec::Mode::Replicated,
          ?replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        ) -> void

        def to_hash: -> {
          global: top,
          global_job: top,
          replicated: DockerEngine::Spec::Mode::Replicated,
          replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        }

        type replicated = { replicas: Integer }

        class Replicated < DockerEngine::Internal::Type::BaseModel
          attr_reader replicas: Integer?

          def replicas=: (Integer) -> Integer

          def initialize: (?replicas: Integer) -> void

          def to_hash: -> { replicas: Integer }
        end

        type replicated_job =
          { max_concurrent: Integer, total_completions: Integer }

        class ReplicatedJob < DockerEngine::Internal::Type::BaseModel
          attr_reader max_concurrent: Integer?

          def max_concurrent=: (Integer) -> Integer

          attr_reader total_completions: Integer?

          def total_completions=: (Integer) -> Integer

          def initialize: (
            ?max_concurrent: Integer,
            ?total_completions: Integer
          ) -> void

          def to_hash: -> {
            max_concurrent: Integer,
            total_completions: Integer
          }
        end
      end

      type network =
        {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }

      class Network < DockerEngine::Internal::Type::BaseModel
        attr_reader aliases: ::Array[String]?

        def aliases=: (::Array[String]) -> ::Array[String]

        attr_reader driver_opts: ::Hash[Symbol, String]?

        def driver_opts=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_reader target: String?

        def target=: (String) -> String

        def initialize: (
          ?aliases: ::Array[String],
          ?driver_opts: ::Hash[Symbol, String],
          ?target: String
        ) -> void

        def to_hash: -> {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }
      end

      type rollback_config =
        {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::RollbackConfig::order,
          parallelism: Integer
        }

      class RollbackConfig < DockerEngine::Internal::Type::BaseModel
        attr_reader delay: Integer?

        def delay=: (Integer) -> Integer

        attr_reader failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action?

        def failure_action=: (
          DockerEngine::Models::Spec::RollbackConfig::failure_action
        ) -> DockerEngine::Models::Spec::RollbackConfig::failure_action

        attr_reader max_failure_ratio: Float?

        def max_failure_ratio=: (Float) -> Float

        attr_reader monitor: Integer?

        def monitor=: (Integer) -> Integer

        attr_reader order: DockerEngine::Models::Spec::RollbackConfig::order?

        def order=: (
          DockerEngine::Models::Spec::RollbackConfig::order
        ) -> DockerEngine::Models::Spec::RollbackConfig::order

        attr_reader parallelism: Integer?

        def parallelism=: (Integer) -> Integer

        def initialize: (
          ?delay: Integer,
          ?failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          ?max_failure_ratio: Float,
          ?monitor: Integer,
          ?order: DockerEngine::Models::Spec::RollbackConfig::order,
          ?parallelism: Integer
        ) -> void

        def to_hash: -> {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::RollbackConfig::order,
          parallelism: Integer
        }

        type failure_action = :continue | :pause

        module FailureAction
          extend DockerEngine::Internal::Type::Enum

          CONTINUE: :continue
          PAUSE: :pause

          def self?.values: -> ::Array[DockerEngine::Models::Spec::RollbackConfig::failure_action]
        end

        type order = :"stop-first" | :"start-first"

        module Order
          extend DockerEngine::Internal::Type::Enum

          STOP_FIRST: :"stop-first"
          START_FIRST: :"start-first"

          def self?.values: -> ::Array[DockerEngine::Models::Spec::RollbackConfig::order]
        end
      end

      type task_template =
        {
          container_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec,
          force_update: Integer,
          log_driver: DockerEngine::Spec::TaskTemplate::LogDriver,
          network_attachment_spec: DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec,
          networks: ::Array[DockerEngine::Spec::TaskTemplate::Network],
          placement: DockerEngine::Spec::TaskTemplate::Placement,
          plugin_spec: DockerEngine::Spec::TaskTemplate::PluginSpec,
          resources: DockerEngine::Spec::TaskTemplate::Resources,
          restart_policy: DockerEngine::Spec::TaskTemplate::RestartPolicy,
          runtime: String
        }

      class TaskTemplate < DockerEngine::Internal::Type::BaseModel
        attr_reader container_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec?

        def container_spec=: (
          DockerEngine::Spec::TaskTemplate::ContainerSpec
        ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec

        attr_reader force_update: Integer?

        def force_update=: (Integer) -> Integer

        attr_reader log_driver: DockerEngine::Spec::TaskTemplate::LogDriver?

        def log_driver=: (
          DockerEngine::Spec::TaskTemplate::LogDriver
        ) -> DockerEngine::Spec::TaskTemplate::LogDriver

        attr_reader network_attachment_spec: DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec?

        def network_attachment_spec=: (
          DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec
        ) -> DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec

        attr_reader networks: ::Array[DockerEngine::Spec::TaskTemplate::Network]?

        def networks=: (
          ::Array[DockerEngine::Spec::TaskTemplate::Network]
        ) -> ::Array[DockerEngine::Spec::TaskTemplate::Network]

        attr_reader placement: DockerEngine::Spec::TaskTemplate::Placement?

        def placement=: (
          DockerEngine::Spec::TaskTemplate::Placement
        ) -> DockerEngine::Spec::TaskTemplate::Placement

        attr_reader plugin_spec: DockerEngine::Spec::TaskTemplate::PluginSpec?

        def plugin_spec=: (
          DockerEngine::Spec::TaskTemplate::PluginSpec
        ) -> DockerEngine::Spec::TaskTemplate::PluginSpec

        attr_reader resources: DockerEngine::Spec::TaskTemplate::Resources?

        def resources=: (
          DockerEngine::Spec::TaskTemplate::Resources
        ) -> DockerEngine::Spec::TaskTemplate::Resources

        attr_reader restart_policy: DockerEngine::Spec::TaskTemplate::RestartPolicy?

        def restart_policy=: (
          DockerEngine::Spec::TaskTemplate::RestartPolicy
        ) -> DockerEngine::Spec::TaskTemplate::RestartPolicy

        attr_reader runtime: String?

        def runtime=: (String) -> String

        def initialize: (
          ?container_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec,
          ?force_update: Integer,
          ?log_driver: DockerEngine::Spec::TaskTemplate::LogDriver,
          ?network_attachment_spec: DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec,
          ?networks: ::Array[DockerEngine::Spec::TaskTemplate::Network],
          ?placement: DockerEngine::Spec::TaskTemplate::Placement,
          ?plugin_spec: DockerEngine::Spec::TaskTemplate::PluginSpec,
          ?resources: DockerEngine::Spec::TaskTemplate::Resources,
          ?restart_policy: DockerEngine::Spec::TaskTemplate::RestartPolicy,
          ?runtime: String
        ) -> void

        def to_hash: -> {
          container_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec,
          force_update: Integer,
          log_driver: DockerEngine::Spec::TaskTemplate::LogDriver,
          network_attachment_spec: DockerEngine::Spec::TaskTemplate::NetworkAttachmentSpec,
          networks: ::Array[DockerEngine::Spec::TaskTemplate::Network],
          placement: DockerEngine::Spec::TaskTemplate::Placement,
          plugin_spec: DockerEngine::Spec::TaskTemplate::PluginSpec,
          resources: DockerEngine::Spec::TaskTemplate::Resources,
          restart_policy: DockerEngine::Spec::TaskTemplate::RestartPolicy,
          runtime: String
        }

        type container_spec =
          {
            args: ::Array[String],
            capability_add: ::Array[String],
            capability_drop: ::Array[String],
            command: ::Array[String],
            configs: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config],
            dir: String,
            dns_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig,
            env: ::Array[String],
            groups: ::Array[String],
            health_check: DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck,
            hostname: String,
            hosts: ::Array[String],
            image: String,
            init: bool?,
            isolation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation,
            labels: ::Hash[Symbol, String],
            mounts: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount],
            oom_score_adj: Integer,
            open_stdin: bool,
            privileges: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges,
            read_only: bool,
            secrets: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret],
            stop_grace_period: Integer,
            stop_signal: String,
            sysctls: ::Hash[Symbol, String],
            tty: bool,
            ulimits: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit],
            user: String
          }

        class ContainerSpec < DockerEngine::Internal::Type::BaseModel
          attr_reader args: ::Array[String]?

          def args=: (::Array[String]) -> ::Array[String]

          attr_reader capability_add: ::Array[String]?

          def capability_add=: (::Array[String]) -> ::Array[String]

          attr_reader capability_drop: ::Array[String]?

          def capability_drop=: (::Array[String]) -> ::Array[String]

          attr_reader command: ::Array[String]?

          def command=: (::Array[String]) -> ::Array[String]

          attr_reader configs: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config]?

          def configs=: (
            ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config]

          attr_reader dir: String?

          def dir=: (String) -> String

          attr_reader dns_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig?

          def dns_config=: (
            DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig
          ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig

          attr_reader env: ::Array[String]?

          def env=: (::Array[String]) -> ::Array[String]

          attr_reader groups: ::Array[String]?

          def groups=: (::Array[String]) -> ::Array[String]

          attr_reader health_check: DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck?

          def health_check=: (
            DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck
          ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck

          attr_reader hostname: String?

          def hostname=: (String) -> String

          attr_reader hosts: ::Array[String]?

          def hosts=: (::Array[String]) -> ::Array[String]

          attr_reader image: String?

          def image=: (String) -> String

          attr_accessor init: bool?

          attr_reader isolation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation?

          def isolation=: (
            DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation
          ) -> DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation

          attr_reader labels: ::Hash[Symbol, String]?

          def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

          attr_reader mounts: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount]?

          def mounts=: (
            ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount]

          attr_reader oom_score_adj: Integer?

          def oom_score_adj=: (Integer) -> Integer

          attr_reader open_stdin: bool?

          def open_stdin=: (bool) -> bool

          attr_reader privileges: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges?

          def privileges=: (
            DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges
          ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges

          attr_reader read_only: bool?

          def read_only=: (bool) -> bool

          attr_reader secrets: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret]?

          def secrets=: (
            ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret]

          attr_reader stop_grace_period: Integer?

          def stop_grace_period=: (Integer) -> Integer

          attr_reader stop_signal: String?

          def stop_signal=: (String) -> String

          attr_reader sysctls: ::Hash[Symbol, String]?

          def sysctls=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

          attr_reader tty: bool?

          def tty=: (bool) -> bool

          attr_reader ulimits: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit]?

          def ulimits=: (
            ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit]

          attr_reader user: String?

          def user=: (String) -> String

          def initialize: (
            ?args: ::Array[String],
            ?capability_add: ::Array[String],
            ?capability_drop: ::Array[String],
            ?command: ::Array[String],
            ?configs: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config],
            ?dir: String,
            ?dns_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig,
            ?env: ::Array[String],
            ?groups: ::Array[String],
            ?health_check: DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck,
            ?hostname: String,
            ?hosts: ::Array[String],
            ?image: String,
            ?init: bool?,
            ?isolation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation,
            ?labels: ::Hash[Symbol, String],
            ?mounts: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount],
            ?oom_score_adj: Integer,
            ?open_stdin: bool,
            ?privileges: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges,
            ?read_only: bool,
            ?secrets: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret],
            ?stop_grace_period: Integer,
            ?stop_signal: String,
            ?sysctls: ::Hash[Symbol, String],
            ?tty: bool,
            ?ulimits: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit],
            ?user: String
          ) -> void

          def to_hash: -> {
            args: ::Array[String],
            capability_add: ::Array[String],
            capability_drop: ::Array[String],
            command: ::Array[String],
            configs: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Config],
            dir: String,
            dns_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::DNSConfig,
            env: ::Array[String],
            groups: ::Array[String],
            health_check: DockerEngine::Spec::TaskTemplate::ContainerSpec::HealthCheck,
            hostname: String,
            hosts: ::Array[String],
            image: String,
            init: bool?,
            isolation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation,
            labels: ::Hash[Symbol, String],
            mounts: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount],
            oom_score_adj: Integer,
            open_stdin: bool,
            privileges: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges,
            read_only: bool,
            secrets: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret],
            stop_grace_period: Integer,
            stop_signal: String,
            sysctls: ::Hash[Symbol, String],
            tty: bool,
            ulimits: ::Array[DockerEngine::Spec::TaskTemplate::ContainerSpec::Ulimit],
            user: String
          }

          type config =
            {
              config_id: String,
              config_name: String,
              file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File,
              runtime: top
            }

          class Config < DockerEngine::Internal::Type::BaseModel
            attr_reader config_id: String?

            def config_id=: (String) -> String

            attr_reader config_name: String?

            def config_name=: (String) -> String

            attr_reader file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File?

            def file=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File

            attr_reader runtime: top?

            def runtime=: (top) -> top

            def initialize: (
              ?config_id: String,
              ?config_name: String,
              ?file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File,
              ?runtime: top
            ) -> void

            def to_hash: -> {
              config_id: String,
              config_name: String,
              file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Config::File,
              runtime: top
            }

            type file =
              { gid: String, mode: Integer, name: String, uid: String }

            class File < DockerEngine::Internal::Type::BaseModel
              attr_reader gid: String?

              def gid=: (String) -> String

              attr_reader mode: Integer?

              def mode=: (Integer) -> Integer

              attr_reader name: String?

              def name=: (String) -> String

              attr_reader uid: String?

              def uid=: (String) -> String

              def initialize: (
                ?gid: String,
                ?mode: Integer,
                ?name: String,
                ?uid: String
              ) -> void

              def to_hash: -> {
                gid: String,
                mode: Integer,
                name: String,
                uid: String
              }
            end
          end

          type dns_config =
            {
              nameservers: ::Array[String],
              options: ::Array[String],
              search: ::Array[String]
            }

          class DNSConfig < DockerEngine::Internal::Type::BaseModel
            attr_reader nameservers: ::Array[String]?

            def nameservers=: (::Array[String]) -> ::Array[String]

            attr_reader options: ::Array[String]?

            def options=: (::Array[String]) -> ::Array[String]

            attr_reader search: ::Array[String]?

            def search=: (::Array[String]) -> ::Array[String]

            def initialize: (
              ?nameservers: ::Array[String],
              ?options: ::Array[String],
              ?search: ::Array[String]
            ) -> void

            def to_hash: -> {
              nameservers: ::Array[String],
              options: ::Array[String],
              search: ::Array[String]
            }
          end

          type health_check =
            {
              interval: Integer,
              retries: Integer,
              start_interval: Integer,
              start_period: Integer,
              test_: ::Array[String],
              timeout: Integer
            }

          class HealthCheck < DockerEngine::Internal::Type::BaseModel
            attr_reader interval: Integer?

            def interval=: (Integer) -> Integer

            attr_reader retries: Integer?

            def retries=: (Integer) -> Integer

            attr_reader start_interval: Integer?

            def start_interval=: (Integer) -> Integer

            attr_reader start_period: Integer?

            def start_period=: (Integer) -> Integer

            attr_reader test_: ::Array[String]?

            def test_=: (::Array[String]) -> ::Array[String]

            attr_reader timeout: Integer?

            def timeout=: (Integer) -> Integer

            def initialize: (
              ?interval: Integer,
              ?retries: Integer,
              ?start_interval: Integer,
              ?start_period: Integer,
              ?test_: ::Array[String],
              ?timeout: Integer
            ) -> void

            def to_hash: -> {
              interval: Integer,
              retries: Integer,
              start_interval: Integer,
              start_period: Integer,
              test_: ::Array[String],
              timeout: Integer
            }
          end

          type isolation = :default | :process | :hyperv | :""

          module Isolation
            extend DockerEngine::Internal::Type::Enum

            DEFAULT: :default
            PROCESS: :process
            HYPERV: :hyperv
            EMPTY: :""

            def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::isolation]
          end

          type mount =
            {
              bind_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions,
              consistency: String,
              image_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions,
              read_only: bool,
              source: String,
              target: String,
              tmpfs_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions,
              type: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_,
              volume_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions
            }

          class Mount < DockerEngine::Internal::Type::BaseModel
            attr_reader bind_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions?

            def bind_options=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions

            attr_reader consistency: String?

            def consistency=: (String) -> String

            attr_reader image_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions?

            def image_options=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions

            attr_reader read_only: bool?

            def read_only=: (bool) -> bool

            attr_reader source: String?

            def source=: (String) -> String

            attr_reader target: String?

            def target=: (String) -> String

            attr_reader tmpfs_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions?

            def tmpfs_options=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions

            attr_reader type: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_?

            def type=: (
              DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_
            ) -> DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_

            attr_reader volume_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions?

            def volume_options=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions

            def initialize: (
              ?bind_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions,
              ?consistency: String,
              ?image_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions,
              ?read_only: bool,
              ?source: String,
              ?target: String,
              ?tmpfs_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions,
              ?type: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_,
              ?volume_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions
            ) -> void

            def to_hash: -> {
              bind_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions,
              consistency: String,
              image_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::ImageOptions,
              read_only: bool,
              source: String,
              target: String,
              tmpfs_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::TmpfsOptions,
              type: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_,
              volume_options: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions
            }

            type bind_options =
              {
                create_mountpoint: bool,
                non_recursive: bool,
                propagation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation,
                read_only_force_recursive: bool,
                read_only_non_recursive: bool
              }

            class BindOptions < DockerEngine::Internal::Type::BaseModel
              attr_reader create_mountpoint: bool?

              def create_mountpoint=: (bool) -> bool

              attr_reader non_recursive: bool?

              def non_recursive=: (bool) -> bool

              attr_reader propagation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation?

              def propagation=: (
                DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation
              ) -> DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation

              attr_reader read_only_force_recursive: bool?

              def read_only_force_recursive=: (bool) -> bool

              attr_reader read_only_non_recursive: bool?

              def read_only_non_recursive=: (bool) -> bool

              def initialize: (
                ?create_mountpoint: bool,
                ?non_recursive: bool,
                ?propagation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation,
                ?read_only_force_recursive: bool,
                ?read_only_non_recursive: bool
              ) -> void

              def to_hash: -> {
                create_mountpoint: bool,
                non_recursive: bool,
                propagation: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation,
                read_only_force_recursive: bool,
                read_only_non_recursive: bool
              }

              type propagation =
                :private | :rprivate | :shared | :rshared | :slave | :rslave

              module Propagation
                extend DockerEngine::Internal::Type::Enum

                PRIVATE: :private
                RPRIVATE: :rprivate
                SHARED: :shared
                RSHARED: :rshared
                SLAVE: :slave
                RSLAVE: :rslave

                def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::BindOptions::propagation]
              end
            end

            type image_options = { subpath: String }

            class ImageOptions < DockerEngine::Internal::Type::BaseModel
              attr_reader subpath: String?

              def subpath=: (String) -> String

              def initialize: (?subpath: String) -> void

              def to_hash: -> { subpath: String }
            end

            type tmpfs_options =
              {
                mode: Integer,
                options: ::Array[::Array[String]],
                size_bytes: Integer
              }

            class TmpfsOptions < DockerEngine::Internal::Type::BaseModel
              attr_reader mode: Integer?

              def mode=: (Integer) -> Integer

              attr_reader options: ::Array[::Array[String]]?

              def options=: (
                ::Array[::Array[String]]
              ) -> ::Array[::Array[String]]

              attr_reader size_bytes: Integer?

              def size_bytes=: (Integer) -> Integer

              def initialize: (
                ?mode: Integer,
                ?options: ::Array[::Array[String]],
                ?size_bytes: Integer
              ) -> void

              def to_hash: -> {
                mode: Integer,
                options: ::Array[::Array[String]],
                size_bytes: Integer
              }
            end

            type type_ = :bind | :cluster | :image | :npipe | :tmpfs | :volume

            module Type
              extend DockerEngine::Internal::Type::Enum

              BIND: :bind
              CLUSTER: :cluster
              IMAGE: :image
              NPIPE: :npipe
              TMPFS: :tmpfs
              VOLUME: :volume

              def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Mount::type_]
            end

            type volume_options =
              {
                driver_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig,
                labels: ::Hash[Symbol, String],
                no_copy: bool,
                subpath: String
              }

            class VolumeOptions < DockerEngine::Internal::Type::BaseModel
              attr_reader driver_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig?

              def driver_config=: (
                DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig
              ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig

              attr_reader labels: ::Hash[Symbol, String]?

              def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

              attr_reader no_copy: bool?

              def no_copy=: (bool) -> bool

              attr_reader subpath: String?

              def subpath=: (String) -> String

              def initialize: (
                ?driver_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig,
                ?labels: ::Hash[Symbol, String],
                ?no_copy: bool,
                ?subpath: String
              ) -> void

              def to_hash: -> {
                driver_config: DockerEngine::Spec::TaskTemplate::ContainerSpec::Mount::VolumeOptions::DriverConfig,
                labels: ::Hash[Symbol, String],
                no_copy: bool,
                subpath: String
              }

              type driver_config =
                { name: String, options: ::Hash[Symbol, String] }

              class DriverConfig < DockerEngine::Internal::Type::BaseModel
                attr_reader name: String?

                def name=: (String) -> String

                attr_reader options: ::Hash[Symbol, String]?

                def options=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

                def initialize: (
                  ?name: String,
                  ?options: ::Hash[Symbol, String]
                ) -> void

                def to_hash: -> {
                  name: String,
                  options: ::Hash[Symbol, String]
                }
              end
            end
          end

          type privileges =
            {
              app_armor: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor,
              credential_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec,
              no_new_privileges: bool,
              seccomp: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp,
              se_linux_context: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext
            }

          class Privileges < DockerEngine::Internal::Type::BaseModel
            attr_reader app_armor: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor?

            def app_armor=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor

            attr_reader credential_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec?

            def credential_spec=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec

            attr_reader no_new_privileges: bool?

            def no_new_privileges=: (bool) -> bool

            attr_reader seccomp: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp?

            def seccomp=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp

            attr_reader se_linux_context: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext?

            def se_linux_context=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext

            def initialize: (
              ?app_armor: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor,
              ?credential_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec,
              ?no_new_privileges: bool,
              ?seccomp: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp,
              ?se_linux_context: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext
            ) -> void

            def to_hash: -> {
              app_armor: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor,
              credential_spec: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::CredentialSpec,
              no_new_privileges: bool,
              seccomp: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp,
              se_linux_context: DockerEngine::Spec::TaskTemplate::ContainerSpec::Privileges::SeLinuxContext
            }

            type app_armor =
              {
                mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode
              }

            class AppArmor < DockerEngine::Internal::Type::BaseModel
              attr_reader mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode?

              def mode=: (
                DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode
              ) -> DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode

              def initialize: (
                ?mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode
              ) -> void

              def to_hash: -> {
                mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode
              }

              type mode = :default | :disabled

              module Mode
                extend DockerEngine::Internal::Type::Enum

                DEFAULT: :default
                DISABLED: :disabled

                def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::AppArmor::mode]
              end
            end

            type credential_spec =
              { config: String, file: String, registry: String }

            class CredentialSpec < DockerEngine::Internal::Type::BaseModel
              attr_reader config: String?

              def config=: (String) -> String

              attr_reader file: String?

              def file=: (String) -> String

              attr_reader registry: String?

              def registry=: (String) -> String

              def initialize: (
                ?config: String,
                ?file: String,
                ?registry: String
              ) -> void

              def to_hash: -> { config: String, file: String, registry: String }
            end

            type seccomp =
              {
                mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode,
                profile: String
              }

            class Seccomp < DockerEngine::Internal::Type::BaseModel
              attr_reader mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode?

              def mode=: (
                DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode
              ) -> DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode

              attr_reader profile: String?

              def profile=: (String) -> String

              def initialize: (
                ?mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode,
                ?profile: String
              ) -> void

              def to_hash: -> {
                mode: DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode,
                profile: String
              }

              type mode = :default | :unconfined | :custom

              module Mode
                extend DockerEngine::Internal::Type::Enum

                DEFAULT: :default
                UNCONFINED: :unconfined
                CUSTOM: :custom

                def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::ContainerSpec::Privileges::Seccomp::mode]
              end
            end

            type se_linux_context =
              {
                disable: bool,
                level: String,
                role: String,
                type: String,
                user: String
              }

            class SeLinuxContext < DockerEngine::Internal::Type::BaseModel
              attr_reader disable: bool?

              def disable=: (bool) -> bool

              attr_reader level: String?

              def level=: (String) -> String

              attr_reader role: String?

              def role=: (String) -> String

              attr_reader type: String?

              def type=: (String) -> String

              attr_reader user: String?

              def user=: (String) -> String

              def initialize: (
                ?disable: bool,
                ?level: String,
                ?role: String,
                ?type: String,
                ?user: String
              ) -> void

              def to_hash: -> {
                disable: bool,
                level: String,
                role: String,
                type: String,
                user: String
              }
            end
          end

          type secret =
            {
              file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File,
              secret_id: String,
              secret_name: String
            }

          class Secret < DockerEngine::Internal::Type::BaseModel
            attr_reader file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File?

            def file=: (
              DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File
            ) -> DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File

            attr_reader secret_id: String?

            def secret_id=: (String) -> String

            attr_reader secret_name: String?

            def secret_name=: (String) -> String

            def initialize: (
              ?file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File,
              ?secret_id: String,
              ?secret_name: String
            ) -> void

            def to_hash: -> {
              file: DockerEngine::Spec::TaskTemplate::ContainerSpec::Secret::File,
              secret_id: String,
              secret_name: String
            }

            type file =
              { gid: String, mode: Integer, name: String, uid: String }

            class File < DockerEngine::Internal::Type::BaseModel
              attr_reader gid: String?

              def gid=: (String) -> String

              attr_reader mode: Integer?

              def mode=: (Integer) -> Integer

              attr_reader name: String?

              def name=: (String) -> String

              attr_reader uid: String?

              def uid=: (String) -> String

              def initialize: (
                ?gid: String,
                ?mode: Integer,
                ?name: String,
                ?uid: String
              ) -> void

              def to_hash: -> {
                gid: String,
                mode: Integer,
                name: String,
                uid: String
              }
            end
          end

          type ulimit = { hard: Integer, name: String, soft: Integer }

          class Ulimit < DockerEngine::Internal::Type::BaseModel
            attr_reader hard: Integer?

            def hard=: (Integer) -> Integer

            attr_reader name: String?

            def name=: (String) -> String

            attr_reader soft: Integer?

            def soft=: (Integer) -> Integer

            def initialize: (
              ?hard: Integer,
              ?name: String,
              ?soft: Integer
            ) -> void

            def to_hash: -> { hard: Integer, name: String, soft: Integer }
          end
        end

        type log_driver = { name: String, options: ::Hash[Symbol, String] }

        class LogDriver < DockerEngine::Internal::Type::BaseModel
          attr_reader name: String?

          def name=: (String) -> String

          attr_reader options: ::Hash[Symbol, String]?

          def options=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

          def initialize: (
            ?name: String,
            ?options: ::Hash[Symbol, String]
          ) -> void

          def to_hash: -> { name: String, options: ::Hash[Symbol, String] }
        end

        type network_attachment_spec = { container_id: String }

        class NetworkAttachmentSpec < DockerEngine::Internal::Type::BaseModel
          attr_reader container_id: String?

          def container_id=: (String) -> String

          def initialize: (?container_id: String) -> void

          def to_hash: -> { container_id: String }
        end

        type network =
          {
            aliases: ::Array[String],
            driver_opts: ::Hash[Symbol, String],
            target: String
          }

        class Network < DockerEngine::Internal::Type::BaseModel
          attr_reader aliases: ::Array[String]?

          def aliases=: (::Array[String]) -> ::Array[String]

          attr_reader driver_opts: ::Hash[Symbol, String]?

          def driver_opts=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

          attr_reader target: String?

          def target=: (String) -> String

          def initialize: (
            ?aliases: ::Array[String],
            ?driver_opts: ::Hash[Symbol, String],
            ?target: String
          ) -> void

          def to_hash: -> {
            aliases: ::Array[String],
            driver_opts: ::Hash[Symbol, String],
            target: String
          }
        end

        type placement =
          {
            constraints: ::Array[String],
            max_replicas: Integer,
            platforms: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform],
            preferences: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]
          }

        class Placement < DockerEngine::Internal::Type::BaseModel
          attr_reader constraints: ::Array[String]?

          def constraints=: (::Array[String]) -> ::Array[String]

          attr_reader max_replicas: Integer?

          def max_replicas=: (Integer) -> Integer

          attr_reader platforms: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform]?

          def platforms=: (
            ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform]

          attr_reader preferences: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]?

          def preferences=: (
            ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]

          def initialize: (
            ?constraints: ::Array[String],
            ?max_replicas: Integer,
            ?platforms: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform],
            ?preferences: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]
          ) -> void

          def to_hash: -> {
            constraints: ::Array[String],
            max_replicas: Integer,
            platforms: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Platform],
            preferences: ::Array[DockerEngine::Spec::TaskTemplate::Placement::Preference]
          }

          type platform = { architecture: String, os: String }

          class Platform < DockerEngine::Internal::Type::BaseModel
            attr_reader architecture: String?

            def architecture=: (String) -> String

            attr_reader os: String?

            def os=: (String) -> String

            def initialize: (?architecture: String, ?os: String) -> void

            def to_hash: -> { architecture: String, os: String }
          end

          type preference =
            {
              spread: DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread
            }

          class Preference < DockerEngine::Internal::Type::BaseModel
            attr_reader spread: DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread?

            def spread=: (
              DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread
            ) -> DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread

            def initialize: (
              ?spread: DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread
            ) -> void

            def to_hash: -> {
              spread: DockerEngine::Spec::TaskTemplate::Placement::Preference::Spread
            }

            type spread = { spread_descriptor: String }

            class Spread < DockerEngine::Internal::Type::BaseModel
              attr_reader spread_descriptor: String?

              def spread_descriptor=: (String) -> String

              def initialize: (?spread_descriptor: String) -> void

              def to_hash: -> { spread_descriptor: String }
            end
          end
        end

        type plugin_spec =
          {
            disabled: bool,
            name: String,
            plugin_privilege: ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege],
            remote: String
          }

        class PluginSpec < DockerEngine::Internal::Type::BaseModel
          attr_reader disabled: bool?

          def disabled=: (bool) -> bool

          attr_reader name: String?

          def name=: (String) -> String

          attr_reader plugin_privilege: ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege]?

          def plugin_privilege=: (
            ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege]
          ) -> ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege]

          attr_reader remote: String?

          def remote=: (String) -> String

          def initialize: (
            ?disabled: bool,
            ?name: String,
            ?plugin_privilege: ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege],
            ?remote: String
          ) -> void

          def to_hash: -> {
            disabled: bool,
            name: String,
            plugin_privilege: ::Array[DockerEngine::Spec::TaskTemplate::PluginSpec::PluginPrivilege],
            remote: String
          }

          type plugin_privilege =
            { description: String, name: String, value: ::Array[String] }

          class PluginPrivilege < DockerEngine::Internal::Type::BaseModel
            attr_reader description: String?

            def description=: (String) -> String

            attr_reader name: String?

            def name=: (String) -> String

            attr_reader value: ::Array[String]?

            def value=: (::Array[String]) -> ::Array[String]

            def initialize: (
              ?description: String,
              ?name: String,
              ?value: ::Array[String]
            ) -> void

            def to_hash: -> {
              description: String,
              name: String,
              value: ::Array[String]
            }
          end
        end

        type resources =
          {
            limits: DockerEngine::Spec::TaskTemplate::Resources::Limits,
            memory_swappiness: Integer?,
            reservations: DockerEngine::Spec::TaskTemplate::Resources::Reservations,
            swap_bytes: Integer?
          }

        class Resources < DockerEngine::Internal::Type::BaseModel
          attr_reader limits: DockerEngine::Spec::TaskTemplate::Resources::Limits?

          def limits=: (
            DockerEngine::Spec::TaskTemplate::Resources::Limits
          ) -> DockerEngine::Spec::TaskTemplate::Resources::Limits

          attr_accessor memory_swappiness: Integer?

          attr_reader reservations: DockerEngine::Spec::TaskTemplate::Resources::Reservations?

          def reservations=: (
            DockerEngine::Spec::TaskTemplate::Resources::Reservations
          ) -> DockerEngine::Spec::TaskTemplate::Resources::Reservations

          attr_accessor swap_bytes: Integer?

          def initialize: (
            ?limits: DockerEngine::Spec::TaskTemplate::Resources::Limits,
            ?memory_swappiness: Integer?,
            ?reservations: DockerEngine::Spec::TaskTemplate::Resources::Reservations,
            ?swap_bytes: Integer?
          ) -> void

          def to_hash: -> {
            limits: DockerEngine::Spec::TaskTemplate::Resources::Limits,
            memory_swappiness: Integer?,
            reservations: DockerEngine::Spec::TaskTemplate::Resources::Reservations,
            swap_bytes: Integer?
          }

          type limits =
            { memory_bytes: Integer, nano_cpus: Integer, pids: Integer }

          class Limits < DockerEngine::Internal::Type::BaseModel
            attr_reader memory_bytes: Integer?

            def memory_bytes=: (Integer) -> Integer

            attr_reader nano_cpus: Integer?

            def nano_cpus=: (Integer) -> Integer

            attr_reader pids: Integer?

            def pids=: (Integer) -> Integer

            def initialize: (
              ?memory_bytes: Integer,
              ?nano_cpus: Integer,
              ?pids: Integer
            ) -> void

            def to_hash: -> {
              memory_bytes: Integer,
              nano_cpus: Integer,
              pids: Integer
            }
          end

          type reservations =
            {
              generic_resources: ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource],
              memory_bytes: Integer,
              nano_cpus: Integer
            }

          class Reservations < DockerEngine::Internal::Type::BaseModel
            attr_reader generic_resources: ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource]?

            def generic_resources=: (
              ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource]
            ) -> ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource]

            attr_reader memory_bytes: Integer?

            def memory_bytes=: (Integer) -> Integer

            attr_reader nano_cpus: Integer?

            def nano_cpus=: (Integer) -> Integer

            def initialize: (
              ?generic_resources: ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource],
              ?memory_bytes: Integer,
              ?nano_cpus: Integer
            ) -> void

            def to_hash: -> {
              generic_resources: ::Array[DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource],
              memory_bytes: Integer,
              nano_cpus: Integer
            }

            type generic_resource =
              {
                discrete_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec,
                named_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec
              }

            class GenericResource < DockerEngine::Internal::Type::BaseModel
              attr_reader discrete_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec?

              def discrete_resource_spec=: (
                DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec
              ) -> DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec

              attr_reader named_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec?

              def named_resource_spec=: (
                DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec
              ) -> DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec

              def initialize: (
                ?discrete_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec,
                ?named_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec
              ) -> void

              def to_hash: -> {
                discrete_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::DiscreteResourceSpec,
                named_resource_spec: DockerEngine::Spec::TaskTemplate::Resources::Reservations::GenericResource::NamedResourceSpec
              }

              type discrete_resource_spec = { kind: String, value: Integer }

              class DiscreteResourceSpec < DockerEngine::Internal::Type::BaseModel
                attr_reader kind: String?

                def kind=: (String) -> String

                attr_reader value: Integer?

                def value=: (Integer) -> Integer

                def initialize: (?kind: String, ?value: Integer) -> void

                def to_hash: -> { kind: String, value: Integer }
              end

              type named_resource_spec = { kind: String, value: String }

              class NamedResourceSpec < DockerEngine::Internal::Type::BaseModel
                attr_reader kind: String?

                def kind=: (String) -> String

                attr_reader value: String?

                def value=: (String) -> String

                def initialize: (?kind: String, ?value: String) -> void

                def to_hash: -> { kind: String, value: String }
              end
            end
          end
        end

        type restart_policy =
          {
            condition: DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition,
            delay: Integer,
            max_attempts: Integer,
            window: Integer
          }

        class RestartPolicy < DockerEngine::Internal::Type::BaseModel
          attr_reader condition: DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition?

          def condition=: (
            DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition
          ) -> DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition

          attr_reader delay: Integer?

          def delay=: (Integer) -> Integer

          attr_reader max_attempts: Integer?

          def max_attempts=: (Integer) -> Integer

          attr_reader window: Integer?

          def window=: (Integer) -> Integer

          def initialize: (
            ?condition: DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition,
            ?delay: Integer,
            ?max_attempts: Integer,
            ?window: Integer
          ) -> void

          def to_hash: -> {
            condition: DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition,
            delay: Integer,
            max_attempts: Integer,
            window: Integer
          }

          type condition = :none | :"on-failure" | :any

          module Condition
            extend DockerEngine::Internal::Type::Enum

            NONE: :none
            ON_FAILURE: :"on-failure"
            ANY: :any

            def self?.values: -> ::Array[DockerEngine::Models::Spec::TaskTemplate::RestartPolicy::condition]
          end
        end
      end

      type update_config =
        {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::UpdateConfig::order,
          parallelism: Integer
        }

      class UpdateConfig < DockerEngine::Internal::Type::BaseModel
        attr_reader delay: Integer?

        def delay=: (Integer) -> Integer

        attr_reader failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action?

        def failure_action=: (
          DockerEngine::Models::Spec::UpdateConfig::failure_action
        ) -> DockerEngine::Models::Spec::UpdateConfig::failure_action

        attr_reader max_failure_ratio: Float?

        def max_failure_ratio=: (Float) -> Float

        attr_reader monitor: Integer?

        def monitor=: (Integer) -> Integer

        attr_reader order: DockerEngine::Models::Spec::UpdateConfig::order?

        def order=: (
          DockerEngine::Models::Spec::UpdateConfig::order
        ) -> DockerEngine::Models::Spec::UpdateConfig::order

        attr_reader parallelism: Integer?

        def parallelism=: (Integer) -> Integer

        def initialize: (
          ?delay: Integer,
          ?failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          ?max_failure_ratio: Float,
          ?monitor: Integer,
          ?order: DockerEngine::Models::Spec::UpdateConfig::order,
          ?parallelism: Integer
        ) -> void

        def to_hash: -> {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::UpdateConfig::order,
          parallelism: Integer
        }

        type failure_action = :continue | :pause | :rollback

        module FailureAction
          extend DockerEngine::Internal::Type::Enum

          CONTINUE: :continue
          PAUSE: :pause
          ROLLBACK: :rollback

          def self?.values: -> ::Array[DockerEngine::Models::Spec::UpdateConfig::failure_action]
        end

        type order = :"stop-first" | :"start-first"

        module Order
          extend DockerEngine::Internal::Type::Enum

          STOP_FIRST: :"stop-first"
          START_FIRST: :"start-first"

          def self?.values: -> ::Array[DockerEngine::Models::Spec::UpdateConfig::order]
        end
      end
    end
  end
end
