module DockerEngine
  module Models
    type spec =
      {
        endpoint_spec: DockerEngine::Spec::EndpointSpec,
        labels: ::Hash[Symbol, String],
        mode: DockerEngine::Spec::Mode,
        name: String,
        networks: ::Array[DockerEngine::Spec::Network],
        rollback_config: DockerEngine::Spec::RollbackConfig,
        task_template: DockerEngine::Spec,
        update_config: DockerEngine::Spec::UpdateConfig
      }

    class Spec < DockerEngine::Internal::Type::BaseModel
      attr_reader endpoint_spec: DockerEngine::Spec::EndpointSpec?

      def endpoint_spec=: (
        DockerEngine::Spec::EndpointSpec
      ) -> DockerEngine::Spec::EndpointSpec

      attr_reader labels: ::Hash[Symbol, String]?

      def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

      attr_reader mode: DockerEngine::Spec::Mode?

      def mode=: (DockerEngine::Spec::Mode) -> DockerEngine::Spec::Mode

      attr_reader name: String?

      def name=: (String) -> String

      attr_reader networks: ::Array[DockerEngine::Spec::Network]?

      def networks=: (
        ::Array[DockerEngine::Spec::Network]
      ) -> ::Array[DockerEngine::Spec::Network]

      attr_reader rollback_config: DockerEngine::Spec::RollbackConfig?

      def rollback_config=: (
        DockerEngine::Spec::RollbackConfig
      ) -> DockerEngine::Spec::RollbackConfig

      attr_reader task_template: DockerEngine::Spec?

      def task_template=: (DockerEngine::Spec) -> DockerEngine::Spec

      attr_reader update_config: DockerEngine::Spec::UpdateConfig?

      def update_config=: (
        DockerEngine::Spec::UpdateConfig
      ) -> DockerEngine::Spec::UpdateConfig

      def initialize: (
        ?endpoint_spec: DockerEngine::Spec::EndpointSpec,
        ?labels: ::Hash[Symbol, String],
        ?mode: DockerEngine::Spec::Mode,
        ?name: String,
        ?networks: ::Array[DockerEngine::Spec::Network],
        ?rollback_config: DockerEngine::Spec::RollbackConfig,
        ?task_template: DockerEngine::Spec,
        ?update_config: DockerEngine::Spec::UpdateConfig
      ) -> void

      def to_hash: -> {
        endpoint_spec: DockerEngine::Spec::EndpointSpec,
        labels: ::Hash[Symbol, String],
        mode: DockerEngine::Spec::Mode,
        name: String,
        networks: ::Array[DockerEngine::Spec::Network],
        rollback_config: DockerEngine::Spec::RollbackConfig,
        task_template: DockerEngine::Spec,
        update_config: DockerEngine::Spec::UpdateConfig
      }

      type endpoint_spec =
        {
          mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        }

      class EndpointSpec < DockerEngine::Internal::Type::BaseModel
        attr_reader mode: DockerEngine::Models::Spec::EndpointSpec::mode?

        def mode=: (
          DockerEngine::Models::Spec::EndpointSpec::mode
        ) -> DockerEngine::Models::Spec::EndpointSpec::mode

        attr_reader ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]?

        def ports=: (
          ::Array[DockerEngine::Spec::EndpointSpec::Port]
        ) -> ::Array[DockerEngine::Spec::EndpointSpec::Port]

        def initialize: (
          ?mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ?ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        ) -> void

        def to_hash: -> {
          mode: DockerEngine::Models::Spec::EndpointSpec::mode,
          ports: ::Array[DockerEngine::Spec::EndpointSpec::Port]
        }

        type mode = :vip | :dnsrr

        module Mode
          extend DockerEngine::Internal::Type::Enum

          VIP: :vip
          DNSRR: :dnsrr

          def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::mode]
        end

        type port =
          {
            name: String,
            protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            target_port: Integer
          }

        class Port < DockerEngine::Internal::Type::BaseModel
          attr_reader name: String?

          def name=: (String) -> String

          attr_reader protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol?

          def protocol=: (
            DockerEngine::Models::Spec::EndpointSpec::Port::protocol
          ) -> DockerEngine::Models::Spec::EndpointSpec::Port::protocol

          attr_reader published_port: Integer?

          def published_port=: (Integer) -> Integer

          attr_reader publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode?

          def publish_mode=: (
            DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode
          ) -> DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode

          attr_reader target_port: Integer?

          def target_port=: (Integer) -> Integer

          def initialize: (
            ?name: String,
            ?protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            ?published_port: Integer,
            ?publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            ?target_port: Integer
          ) -> void

          def to_hash: -> {
            name: String,
            protocol: DockerEngine::Models::Spec::EndpointSpec::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode,
            target_port: Integer
          }

          type protocol = :tcp | :udp | :sctp

          module Protocol
            extend DockerEngine::Internal::Type::Enum

            TCP: :tcp
            UDP: :udp
            SCTP: :sctp

            def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::Port::protocol]
          end

          type publish_mode = :ingress | :host

          module PublishMode
            extend DockerEngine::Internal::Type::Enum

            INGRESS: :ingress
            HOST: :host

            def self?.values: -> ::Array[DockerEngine::Models::Spec::EndpointSpec::Port::publish_mode]
          end
        end
      end

      type mode =
        {
          global: top,
          global_job: top,
          replicated: DockerEngine::Spec::Mode::Replicated,
          replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        }

      class Mode < DockerEngine::Internal::Type::BaseModel
        attr_reader global: top?

        def global=: (top) -> top

        attr_reader global_job: top?

        def global_job=: (top) -> top

        attr_reader replicated: DockerEngine::Spec::Mode::Replicated?

        def replicated=: (
          DockerEngine::Spec::Mode::Replicated
        ) -> DockerEngine::Spec::Mode::Replicated

        attr_reader replicated_job: DockerEngine::Spec::Mode::ReplicatedJob?

        def replicated_job=: (
          DockerEngine::Spec::Mode::ReplicatedJob
        ) -> DockerEngine::Spec::Mode::ReplicatedJob

        def initialize: (
          ?global: top,
          ?global_job: top,
          ?replicated: DockerEngine::Spec::Mode::Replicated,
          ?replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        ) -> void

        def to_hash: -> {
          global: top,
          global_job: top,
          replicated: DockerEngine::Spec::Mode::Replicated,
          replicated_job: DockerEngine::Spec::Mode::ReplicatedJob
        }

        type replicated = { replicas: Integer }

        class Replicated < DockerEngine::Internal::Type::BaseModel
          attr_reader replicas: Integer?

          def replicas=: (Integer) -> Integer

          def initialize: (?replicas: Integer) -> void

          def to_hash: -> { replicas: Integer }
        end

        type replicated_job =
          { max_concurrent: Integer, total_completions: Integer }

        class ReplicatedJob < DockerEngine::Internal::Type::BaseModel
          attr_reader max_concurrent: Integer?

          def max_concurrent=: (Integer) -> Integer

          attr_reader total_completions: Integer?

          def total_completions=: (Integer) -> Integer

          def initialize: (
            ?max_concurrent: Integer,
            ?total_completions: Integer
          ) -> void

          def to_hash: -> {
            max_concurrent: Integer,
            total_completions: Integer
          }
        end
      end

      type network =
        {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }

      class Network < DockerEngine::Internal::Type::BaseModel
        attr_reader aliases: ::Array[String]?

        def aliases=: (::Array[String]) -> ::Array[String]

        attr_reader driver_opts: ::Hash[Symbol, String]?

        def driver_opts=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_reader target: String?

        def target=: (String) -> String

        def initialize: (
          ?aliases: ::Array[String],
          ?driver_opts: ::Hash[Symbol, String],
          ?target: String
        ) -> void

        def to_hash: -> {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }
      end

      type rollback_config =
        {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::RollbackConfig::order,
          parallelism: Integer
        }

      class RollbackConfig < DockerEngine::Internal::Type::BaseModel
        attr_reader delay: Integer?

        def delay=: (Integer) -> Integer

        attr_reader failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action?

        def failure_action=: (
          DockerEngine::Models::Spec::RollbackConfig::failure_action
        ) -> DockerEngine::Models::Spec::RollbackConfig::failure_action

        attr_reader max_failure_ratio: Float?

        def max_failure_ratio=: (Float) -> Float

        attr_reader monitor: Integer?

        def monitor=: (Integer) -> Integer

        attr_reader order: DockerEngine::Models::Spec::RollbackConfig::order?

        def order=: (
          DockerEngine::Models::Spec::RollbackConfig::order
        ) -> DockerEngine::Models::Spec::RollbackConfig::order

        attr_reader parallelism: Integer?

        def parallelism=: (Integer) -> Integer

        def initialize: (
          ?delay: Integer,
          ?failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          ?max_failure_ratio: Float,
          ?monitor: Integer,
          ?order: DockerEngine::Models::Spec::RollbackConfig::order,
          ?parallelism: Integer
        ) -> void

        def to_hash: -> {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::RollbackConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::RollbackConfig::order,
          parallelism: Integer
        }

        type failure_action = :continue | :pause

        module FailureAction
          extend DockerEngine::Internal::Type::Enum

          CONTINUE: :continue
          PAUSE: :pause

          def self?.values: -> ::Array[DockerEngine::Models::Spec::RollbackConfig::failure_action]
        end

        type order = :"stop-first" | :"start-first"

        module Order
          extend DockerEngine::Internal::Type::Enum

          STOP_FIRST: :"stop-first"
          START_FIRST: :"start-first"

          def self?.values: -> ::Array[DockerEngine::Models::Spec::RollbackConfig::order]
        end
      end

      type update_config =
        {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::UpdateConfig::order,
          parallelism: Integer
        }

      class UpdateConfig < DockerEngine::Internal::Type::BaseModel
        attr_reader delay: Integer?

        def delay=: (Integer) -> Integer

        attr_reader failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action?

        def failure_action=: (
          DockerEngine::Models::Spec::UpdateConfig::failure_action
        ) -> DockerEngine::Models::Spec::UpdateConfig::failure_action

        attr_reader max_failure_ratio: Float?

        def max_failure_ratio=: (Float) -> Float

        attr_reader monitor: Integer?

        def monitor=: (Integer) -> Integer

        attr_reader order: DockerEngine::Models::Spec::UpdateConfig::order?

        def order=: (
          DockerEngine::Models::Spec::UpdateConfig::order
        ) -> DockerEngine::Models::Spec::UpdateConfig::order

        attr_reader parallelism: Integer?

        def parallelism=: (Integer) -> Integer

        def initialize: (
          ?delay: Integer,
          ?failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          ?max_failure_ratio: Float,
          ?monitor: Integer,
          ?order: DockerEngine::Models::Spec::UpdateConfig::order,
          ?parallelism: Integer
        ) -> void

        def to_hash: -> {
          delay: Integer,
          failure_action: DockerEngine::Models::Spec::UpdateConfig::failure_action,
          max_failure_ratio: Float,
          monitor: Integer,
          order: DockerEngine::Models::Spec::UpdateConfig::order,
          parallelism: Integer
        }

        type failure_action = :continue | :pause | :rollback

        module FailureAction
          extend DockerEngine::Internal::Type::Enum

          CONTINUE: :continue
          PAUSE: :pause
          ROLLBACK: :rollback

          def self?.values: -> ::Array[DockerEngine::Models::Spec::UpdateConfig::failure_action]
        end

        type order = :"stop-first" | :"start-first"

        module Order
          extend DockerEngine::Internal::Type::Enum

          STOP_FIRST: :"stop-first"
          START_FIRST: :"start-first"

          def self?.values: -> ::Array[DockerEngine::Models::Spec::UpdateConfig::order]
        end
      end
    end
  end
end
