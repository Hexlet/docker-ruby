module DockerEngine
  module Models
    type service =
      {
        created_at: String,
        endpoint: DockerEngine::Service::Endpoint,
        id: String,
        job_status: DockerEngine::Service::JobStatus,
        service_status: DockerEngine::Service::ServiceStatus,
        spec: DockerEngine::Spec,
        updated_at: String,
        update_status: DockerEngine::Service::UpdateStatus,
        version: DockerEngine::Service::Version
      }

    class Service < DockerEngine::Internal::Type::BaseModel
      attr_reader created_at: String?

      def created_at=: (String) -> String

      attr_reader endpoint: DockerEngine::Service::Endpoint?

      def endpoint=: (
        DockerEngine::Service::Endpoint
      ) -> DockerEngine::Service::Endpoint

      attr_reader id: String?

      def id=: (String) -> String

      attr_reader job_status: DockerEngine::Service::JobStatus?

      def job_status=: (
        DockerEngine::Service::JobStatus
      ) -> DockerEngine::Service::JobStatus

      attr_reader service_status: DockerEngine::Service::ServiceStatus?

      def service_status=: (
        DockerEngine::Service::ServiceStatus
      ) -> DockerEngine::Service::ServiceStatus

      attr_reader spec: DockerEngine::Spec?

      def spec=: (DockerEngine::Spec) -> DockerEngine::Spec

      attr_reader updated_at: String?

      def updated_at=: (String) -> String

      attr_reader update_status: DockerEngine::Service::UpdateStatus?

      def update_status=: (
        DockerEngine::Service::UpdateStatus
      ) -> DockerEngine::Service::UpdateStatus

      attr_reader version: DockerEngine::Service::Version?

      def version=: (
        DockerEngine::Service::Version
      ) -> DockerEngine::Service::Version

      def initialize: (
        ?created_at: String,
        ?endpoint: DockerEngine::Service::Endpoint,
        ?id: String,
        ?job_status: DockerEngine::Service::JobStatus,
        ?service_status: DockerEngine::Service::ServiceStatus,
        ?spec: DockerEngine::Spec,
        ?updated_at: String,
        ?update_status: DockerEngine::Service::UpdateStatus,
        ?version: DockerEngine::Service::Version
      ) -> void

      def to_hash: -> {
        created_at: String,
        endpoint: DockerEngine::Service::Endpoint,
        id: String,
        job_status: DockerEngine::Service::JobStatus,
        service_status: DockerEngine::Service::ServiceStatus,
        spec: DockerEngine::Spec,
        updated_at: String,
        update_status: DockerEngine::Service::UpdateStatus,
        version: DockerEngine::Service::Version
      }

      type endpoint =
        {
          ports: ::Array[DockerEngine::Service::Endpoint::Port],
          spec: DockerEngine::Service::Endpoint::Spec,
          virtual_ips: ::Array[DockerEngine::Service::Endpoint::VirtualIP]
        }

      class Endpoint < DockerEngine::Internal::Type::BaseModel
        attr_reader ports: ::Array[DockerEngine::Service::Endpoint::Port]?

        def ports=: (
          ::Array[DockerEngine::Service::Endpoint::Port]
        ) -> ::Array[DockerEngine::Service::Endpoint::Port]

        attr_reader spec: DockerEngine::Service::Endpoint::Spec?

        def spec=: (
          DockerEngine::Service::Endpoint::Spec
        ) -> DockerEngine::Service::Endpoint::Spec

        attr_reader virtual_ips: ::Array[DockerEngine::Service::Endpoint::VirtualIP]?

        def virtual_ips=: (
          ::Array[DockerEngine::Service::Endpoint::VirtualIP]
        ) -> ::Array[DockerEngine::Service::Endpoint::VirtualIP]

        def initialize: (
          ?ports: ::Array[DockerEngine::Service::Endpoint::Port],
          ?spec: DockerEngine::Service::Endpoint::Spec,
          ?virtual_ips: ::Array[DockerEngine::Service::Endpoint::VirtualIP]
        ) -> void

        def to_hash: -> {
          ports: ::Array[DockerEngine::Service::Endpoint::Port],
          spec: DockerEngine::Service::Endpoint::Spec,
          virtual_ips: ::Array[DockerEngine::Service::Endpoint::VirtualIP]
        }

        type port =
          {
            name: String,
            protocol: DockerEngine::Models::Service::Endpoint::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Service::Endpoint::Port::publish_mode,
            target_port: Integer
          }

        class Port < DockerEngine::Internal::Type::BaseModel
          attr_reader name: String?

          def name=: (String) -> String

          attr_reader protocol: DockerEngine::Models::Service::Endpoint::Port::protocol?

          def protocol=: (
            DockerEngine::Models::Service::Endpoint::Port::protocol
          ) -> DockerEngine::Models::Service::Endpoint::Port::protocol

          attr_reader published_port: Integer?

          def published_port=: (Integer) -> Integer

          attr_reader publish_mode: DockerEngine::Models::Service::Endpoint::Port::publish_mode?

          def publish_mode=: (
            DockerEngine::Models::Service::Endpoint::Port::publish_mode
          ) -> DockerEngine::Models::Service::Endpoint::Port::publish_mode

          attr_reader target_port: Integer?

          def target_port=: (Integer) -> Integer

          def initialize: (
            ?name: String,
            ?protocol: DockerEngine::Models::Service::Endpoint::Port::protocol,
            ?published_port: Integer,
            ?publish_mode: DockerEngine::Models::Service::Endpoint::Port::publish_mode,
            ?target_port: Integer
          ) -> void

          def to_hash: -> {
            name: String,
            protocol: DockerEngine::Models::Service::Endpoint::Port::protocol,
            published_port: Integer,
            publish_mode: DockerEngine::Models::Service::Endpoint::Port::publish_mode,
            target_port: Integer
          }

          type protocol = :tcp | :udp | :sctp

          module Protocol
            extend DockerEngine::Internal::Type::Enum

            TCP: :tcp
            UDP: :udp
            SCTP: :sctp

            def self?.values: -> ::Array[DockerEngine::Models::Service::Endpoint::Port::protocol]
          end

          type publish_mode = :ingress | :host

          module PublishMode
            extend DockerEngine::Internal::Type::Enum

            INGRESS: :ingress
            HOST: :host

            def self?.values: -> ::Array[DockerEngine::Models::Service::Endpoint::Port::publish_mode]
          end
        end

        type spec =
          {
            mode: DockerEngine::Models::Service::Endpoint::Spec::mode,
            ports: ::Array[DockerEngine::Service::Endpoint::Spec::Port]
          }

        class Spec < DockerEngine::Internal::Type::BaseModel
          attr_reader mode: DockerEngine::Models::Service::Endpoint::Spec::mode?

          def mode=: (
            DockerEngine::Models::Service::Endpoint::Spec::mode
          ) -> DockerEngine::Models::Service::Endpoint::Spec::mode

          attr_reader ports: ::Array[DockerEngine::Service::Endpoint::Spec::Port]?

          def ports=: (
            ::Array[DockerEngine::Service::Endpoint::Spec::Port]
          ) -> ::Array[DockerEngine::Service::Endpoint::Spec::Port]

          def initialize: (
            ?mode: DockerEngine::Models::Service::Endpoint::Spec::mode,
            ?ports: ::Array[DockerEngine::Service::Endpoint::Spec::Port]
          ) -> void

          def to_hash: -> {
            mode: DockerEngine::Models::Service::Endpoint::Spec::mode,
            ports: ::Array[DockerEngine::Service::Endpoint::Spec::Port]
          }

          type mode = :vip | :dnsrr

          module Mode
            extend DockerEngine::Internal::Type::Enum

            VIP: :vip
            DNSRR: :dnsrr

            def self?.values: -> ::Array[DockerEngine::Models::Service::Endpoint::Spec::mode]
          end

          type port =
            {
              name: String,
              protocol: DockerEngine::Models::Service::Endpoint::Spec::Port::protocol,
              published_port: Integer,
              publish_mode: DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode,
              target_port: Integer
            }

          class Port < DockerEngine::Internal::Type::BaseModel
            attr_reader name: String?

            def name=: (String) -> String

            attr_reader protocol: DockerEngine::Models::Service::Endpoint::Spec::Port::protocol?

            def protocol=: (
              DockerEngine::Models::Service::Endpoint::Spec::Port::protocol
            ) -> DockerEngine::Models::Service::Endpoint::Spec::Port::protocol

            attr_reader published_port: Integer?

            def published_port=: (Integer) -> Integer

            attr_reader publish_mode: DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode?

            def publish_mode=: (
              DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode
            ) -> DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode

            attr_reader target_port: Integer?

            def target_port=: (Integer) -> Integer

            def initialize: (
              ?name: String,
              ?protocol: DockerEngine::Models::Service::Endpoint::Spec::Port::protocol,
              ?published_port: Integer,
              ?publish_mode: DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode,
              ?target_port: Integer
            ) -> void

            def to_hash: -> {
              name: String,
              protocol: DockerEngine::Models::Service::Endpoint::Spec::Port::protocol,
              published_port: Integer,
              publish_mode: DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode,
              target_port: Integer
            }

            type protocol = :tcp | :udp | :sctp

            module Protocol
              extend DockerEngine::Internal::Type::Enum

              TCP: :tcp
              UDP: :udp
              SCTP: :sctp

              def self?.values: -> ::Array[DockerEngine::Models::Service::Endpoint::Spec::Port::protocol]
            end

            type publish_mode = :ingress | :host

            module PublishMode
              extend DockerEngine::Internal::Type::Enum

              INGRESS: :ingress
              HOST: :host

              def self?.values: -> ::Array[DockerEngine::Models::Service::Endpoint::Spec::Port::publish_mode]
            end
          end
        end

        type virtual_ip = { addr: String, network_id: String }

        class VirtualIP < DockerEngine::Internal::Type::BaseModel
          attr_reader addr: String?

          def addr=: (String) -> String

          attr_reader network_id: String?

          def network_id=: (String) -> String

          def initialize: (?addr: String, ?network_id: String) -> void

          def to_hash: -> { addr: String, network_id: String }
        end
      end

      type job_status =
        {
          job_iteration: DockerEngine::Service::JobStatus::JobIteration,
          last_execution: String
        }

      class JobStatus < DockerEngine::Internal::Type::BaseModel
        attr_reader job_iteration: DockerEngine::Service::JobStatus::JobIteration?

        def job_iteration=: (
          DockerEngine::Service::JobStatus::JobIteration
        ) -> DockerEngine::Service::JobStatus::JobIteration

        attr_reader last_execution: String?

        def last_execution=: (String) -> String

        def initialize: (
          ?job_iteration: DockerEngine::Service::JobStatus::JobIteration,
          ?last_execution: String
        ) -> void

        def to_hash: -> {
          job_iteration: DockerEngine::Service::JobStatus::JobIteration,
          last_execution: String
        }

        type job_iteration = { index: Integer }

        class JobIteration < DockerEngine::Internal::Type::BaseModel
          attr_reader index: Integer?

          def index=: (Integer) -> Integer

          def initialize: (?index: Integer) -> void

          def to_hash: -> { index: Integer }
        end
      end

      type service_status =
        {
          completed_tasks: Integer,
          desired_tasks: Integer,
          running_tasks: Integer
        }

      class ServiceStatus < DockerEngine::Internal::Type::BaseModel
        attr_reader completed_tasks: Integer?

        def completed_tasks=: (Integer) -> Integer

        attr_reader desired_tasks: Integer?

        def desired_tasks=: (Integer) -> Integer

        attr_reader running_tasks: Integer?

        def running_tasks=: (Integer) -> Integer

        def initialize: (
          ?completed_tasks: Integer,
          ?desired_tasks: Integer,
          ?running_tasks: Integer
        ) -> void

        def to_hash: -> {
          completed_tasks: Integer,
          desired_tasks: Integer,
          running_tasks: Integer
        }
      end

      type update_status =
        {
          completed_at: String,
          message: String,
          started_at: String,
          state: DockerEngine::Models::Service::UpdateStatus::state
        }

      class UpdateStatus < DockerEngine::Internal::Type::BaseModel
        attr_reader completed_at: String?

        def completed_at=: (String) -> String

        attr_reader message: String?

        def message=: (String) -> String

        attr_reader started_at: String?

        def started_at=: (String) -> String

        attr_reader state: DockerEngine::Models::Service::UpdateStatus::state?

        def state=: (
          DockerEngine::Models::Service::UpdateStatus::state
        ) -> DockerEngine::Models::Service::UpdateStatus::state

        def initialize: (
          ?completed_at: String,
          ?message: String,
          ?started_at: String,
          ?state: DockerEngine::Models::Service::UpdateStatus::state
        ) -> void

        def to_hash: -> {
          completed_at: String,
          message: String,
          started_at: String,
          state: DockerEngine::Models::Service::UpdateStatus::state
        }

        type state = :updating | :paused | :completed

        module State
          extend DockerEngine::Internal::Type::Enum

          UPDATING: :updating
          PAUSED: :paused
          COMPLETED: :completed

          def self?.values: -> ::Array[DockerEngine::Models::Service::UpdateStatus::state]
        end
      end

      type version = { index: Integer }

      class Version < DockerEngine::Internal::Type::BaseModel
        attr_reader index: Integer?

        def index=: (Integer) -> Integer

        def initialize: (?index: Integer) -> void

        def to_hash: -> { index: Integer }
      end
    end
  end
end
