module DockerEngine
  module Models
    type task =
      {
        assigned_generic_resources: ::Array[DockerEngine::Task::AssignedGenericResource],
        created_at: String,
        desired_state: DockerEngine::Models::Task::desired_state,
        id: String,
        job_iteration: DockerEngine::Task::JobIteration,
        labels: ::Hash[Symbol, String],
        name: String,
        node_id: String,
        service_id: String,
        slot: Integer,
        spec: DockerEngine::Spec,
        status: DockerEngine::Task::Status,
        updated_at: String,
        version: DockerEngine::Task::Version
      }

    class Task < DockerEngine::Internal::Type::BaseModel
      attr_reader assigned_generic_resources: ::Array[DockerEngine::Task::AssignedGenericResource]?

      def assigned_generic_resources=: (
        ::Array[DockerEngine::Task::AssignedGenericResource]
      ) -> ::Array[DockerEngine::Task::AssignedGenericResource]

      attr_reader created_at: String?

      def created_at=: (String) -> String

      attr_reader desired_state: DockerEngine::Models::Task::desired_state?

      def desired_state=: (
        DockerEngine::Models::Task::desired_state
      ) -> DockerEngine::Models::Task::desired_state

      attr_reader id: String?

      def id=: (String) -> String

      attr_reader job_iteration: DockerEngine::Task::JobIteration?

      def job_iteration=: (
        DockerEngine::Task::JobIteration
      ) -> DockerEngine::Task::JobIteration

      attr_reader labels: ::Hash[Symbol, String]?

      def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

      attr_reader name: String?

      def name=: (String) -> String

      attr_reader node_id: String?

      def node_id=: (String) -> String

      attr_reader service_id: String?

      def service_id=: (String) -> String

      attr_reader slot: Integer?

      def slot=: (Integer) -> Integer

      attr_reader spec: DockerEngine::Spec?

      def spec=: (DockerEngine::Spec) -> DockerEngine::Spec

      attr_reader status: DockerEngine::Task::Status?

      def status=: (DockerEngine::Task::Status) -> DockerEngine::Task::Status

      attr_reader updated_at: String?

      def updated_at=: (String) -> String

      attr_reader version: DockerEngine::Task::Version?

      def version=: (DockerEngine::Task::Version) -> DockerEngine::Task::Version

      def initialize: (
        ?assigned_generic_resources: ::Array[DockerEngine::Task::AssignedGenericResource],
        ?created_at: String,
        ?desired_state: DockerEngine::Models::Task::desired_state,
        ?id: String,
        ?job_iteration: DockerEngine::Task::JobIteration,
        ?labels: ::Hash[Symbol, String],
        ?name: String,
        ?node_id: String,
        ?service_id: String,
        ?slot: Integer,
        ?spec: DockerEngine::Spec,
        ?status: DockerEngine::Task::Status,
        ?updated_at: String,
        ?version: DockerEngine::Task::Version
      ) -> void

      def to_hash: -> {
        assigned_generic_resources: ::Array[DockerEngine::Task::AssignedGenericResource],
        created_at: String,
        desired_state: DockerEngine::Models::Task::desired_state,
        id: String,
        job_iteration: DockerEngine::Task::JobIteration,
        labels: ::Hash[Symbol, String],
        name: String,
        node_id: String,
        service_id: String,
        slot: Integer,
        spec: DockerEngine::Spec,
        status: DockerEngine::Task::Status,
        updated_at: String,
        version: DockerEngine::Task::Version
      }

      type assigned_generic_resource =
        {
          discrete_resource_spec: DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec,
          named_resource_spec: DockerEngine::Task::AssignedGenericResource::NamedResourceSpec
        }

      class AssignedGenericResource < DockerEngine::Internal::Type::BaseModel
        attr_reader discrete_resource_spec: DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec?

        def discrete_resource_spec=: (
          DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec
        ) -> DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec

        attr_reader named_resource_spec: DockerEngine::Task::AssignedGenericResource::NamedResourceSpec?

        def named_resource_spec=: (
          DockerEngine::Task::AssignedGenericResource::NamedResourceSpec
        ) -> DockerEngine::Task::AssignedGenericResource::NamedResourceSpec

        def initialize: (
          ?discrete_resource_spec: DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec,
          ?named_resource_spec: DockerEngine::Task::AssignedGenericResource::NamedResourceSpec
        ) -> void

        def to_hash: -> {
          discrete_resource_spec: DockerEngine::Task::AssignedGenericResource::DiscreteResourceSpec,
          named_resource_spec: DockerEngine::Task::AssignedGenericResource::NamedResourceSpec
        }

        type discrete_resource_spec = { kind: String, value: Integer }

        class DiscreteResourceSpec < DockerEngine::Internal::Type::BaseModel
          attr_reader kind: String?

          def kind=: (String) -> String

          attr_reader value: Integer?

          def value=: (Integer) -> Integer

          def initialize: (?kind: String, ?value: Integer) -> void

          def to_hash: -> { kind: String, value: Integer }
        end

        type named_resource_spec = { kind: String, value: String }

        class NamedResourceSpec < DockerEngine::Internal::Type::BaseModel
          attr_reader kind: String?

          def kind=: (String) -> String

          attr_reader value: String?

          def value=: (String) -> String

          def initialize: (?kind: String, ?value: String) -> void

          def to_hash: -> { kind: String, value: String }
        end
      end

      type desired_state =
        :new
        | :allocated
        | :pending
        | :assigned
        | :accepted
        | :preparing
        | :ready
        | :starting
        | :running
        | :complete
        | :shutdown
        | :failed
        | :rejected
        | :remove
        | :orphaned

      module DesiredState
        extend DockerEngine::Internal::Type::Enum

        NEW: :new
        ALLOCATED: :allocated
        PENDING: :pending
        ASSIGNED: :assigned
        ACCEPTED: :accepted
        PREPARING: :preparing
        READY: :ready
        STARTING: :starting
        RUNNING: :running
        COMPLETE: :complete
        SHUTDOWN: :shutdown
        FAILED: :failed
        REJECTED: :rejected
        REMOVE: :remove
        ORPHANED: :orphaned

        def self?.values: -> ::Array[DockerEngine::Models::Task::desired_state]
      end

      type job_iteration = { index: Integer }

      class JobIteration < DockerEngine::Internal::Type::BaseModel
        attr_reader index: Integer?

        def index=: (Integer) -> Integer

        def initialize: (?index: Integer) -> void

        def to_hash: -> { index: Integer }
      end

      type status =
        {
          container_status: DockerEngine::Task::Status::ContainerStatus,
          err: String,
          message: String,
          port_status: DockerEngine::Task::Status::PortStatus,
          state: DockerEngine::Models::Task::Status::state,
          timestamp: String
        }

      class Status < DockerEngine::Internal::Type::BaseModel
        attr_reader container_status: DockerEngine::Task::Status::ContainerStatus?

        def container_status=: (
          DockerEngine::Task::Status::ContainerStatus
        ) -> DockerEngine::Task::Status::ContainerStatus

        attr_reader err: String?

        def err=: (String) -> String

        attr_reader message: String?

        def message=: (String) -> String

        attr_reader port_status: DockerEngine::Task::Status::PortStatus?

        def port_status=: (
          DockerEngine::Task::Status::PortStatus
        ) -> DockerEngine::Task::Status::PortStatus

        attr_reader state: DockerEngine::Models::Task::Status::state?

        def state=: (
          DockerEngine::Models::Task::Status::state
        ) -> DockerEngine::Models::Task::Status::state

        attr_reader timestamp: String?

        def timestamp=: (String) -> String

        def initialize: (
          ?container_status: DockerEngine::Task::Status::ContainerStatus,
          ?err: String,
          ?message: String,
          ?port_status: DockerEngine::Task::Status::PortStatus,
          ?state: DockerEngine::Models::Task::Status::state,
          ?timestamp: String
        ) -> void

        def to_hash: -> {
          container_status: DockerEngine::Task::Status::ContainerStatus,
          err: String,
          message: String,
          port_status: DockerEngine::Task::Status::PortStatus,
          state: DockerEngine::Models::Task::Status::state,
          timestamp: String
        }

        type container_status =
          { container_id: String, exit_code: Integer, pid: Integer }

        class ContainerStatus < DockerEngine::Internal::Type::BaseModel
          attr_reader container_id: String?

          def container_id=: (String) -> String

          attr_reader exit_code: Integer?

          def exit_code=: (Integer) -> Integer

          attr_reader pid: Integer?

          def pid=: (Integer) -> Integer

          def initialize: (
            ?container_id: String,
            ?exit_code: Integer,
            ?pid: Integer
          ) -> void

          def to_hash: -> {
            container_id: String,
            exit_code: Integer,
            pid: Integer
          }
        end

        type port_status =
          { ports: ::Array[DockerEngine::Task::Status::PortStatus::Port] }

        class PortStatus < DockerEngine::Internal::Type::BaseModel
          attr_reader ports: ::Array[DockerEngine::Task::Status::PortStatus::Port]?

          def ports=: (
            ::Array[DockerEngine::Task::Status::PortStatus::Port]
          ) -> ::Array[DockerEngine::Task::Status::PortStatus::Port]

          def initialize: (
            ?ports: ::Array[DockerEngine::Task::Status::PortStatus::Port]
          ) -> void

          def to_hash: -> {
            ports: ::Array[DockerEngine::Task::Status::PortStatus::Port]
          }

          type port =
            {
              name: String,
              protocol: DockerEngine::Models::Task::Status::PortStatus::Port::protocol,
              published_port: Integer,
              publish_mode: DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode,
              target_port: Integer
            }

          class Port < DockerEngine::Internal::Type::BaseModel
            attr_reader name: String?

            def name=: (String) -> String

            attr_reader protocol: DockerEngine::Models::Task::Status::PortStatus::Port::protocol?

            def protocol=: (
              DockerEngine::Models::Task::Status::PortStatus::Port::protocol
            ) -> DockerEngine::Models::Task::Status::PortStatus::Port::protocol

            attr_reader published_port: Integer?

            def published_port=: (Integer) -> Integer

            attr_reader publish_mode: DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode?

            def publish_mode=: (
              DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode
            ) -> DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode

            attr_reader target_port: Integer?

            def target_port=: (Integer) -> Integer

            def initialize: (
              ?name: String,
              ?protocol: DockerEngine::Models::Task::Status::PortStatus::Port::protocol,
              ?published_port: Integer,
              ?publish_mode: DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode,
              ?target_port: Integer
            ) -> void

            def to_hash: -> {
              name: String,
              protocol: DockerEngine::Models::Task::Status::PortStatus::Port::protocol,
              published_port: Integer,
              publish_mode: DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode,
              target_port: Integer
            }

            type protocol = :tcp | :udp | :sctp

            module Protocol
              extend DockerEngine::Internal::Type::Enum

              TCP: :tcp
              UDP: :udp
              SCTP: :sctp

              def self?.values: -> ::Array[DockerEngine::Models::Task::Status::PortStatus::Port::protocol]
            end

            type publish_mode = :ingress | :host

            module PublishMode
              extend DockerEngine::Internal::Type::Enum

              INGRESS: :ingress
              HOST: :host

              def self?.values: -> ::Array[DockerEngine::Models::Task::Status::PortStatus::Port::publish_mode]
            end
          end
        end

        type state =
          :new
          | :allocated
          | :pending
          | :assigned
          | :accepted
          | :preparing
          | :ready
          | :starting
          | :running
          | :complete
          | :shutdown
          | :failed
          | :rejected
          | :remove
          | :orphaned

        module State
          extend DockerEngine::Internal::Type::Enum

          NEW: :new
          ALLOCATED: :allocated
          PENDING: :pending
          ASSIGNED: :assigned
          ACCEPTED: :accepted
          PREPARING: :preparing
          READY: :ready
          STARTING: :starting
          RUNNING: :running
          COMPLETE: :complete
          SHUTDOWN: :shutdown
          FAILED: :failed
          REJECTED: :rejected
          REMOVE: :remove
          ORPHANED: :orphaned

          def self?.values: -> ::Array[DockerEngine::Models::Task::Status::state]
        end
      end

      type version = { index: Integer }

      class Version < DockerEngine::Internal::Type::BaseModel
        attr_reader index: Integer?

        def index=: (Integer) -> Integer

        def initialize: (?index: Integer) -> void

        def to_hash: -> { index: Integer }
      end
    end
  end
end
