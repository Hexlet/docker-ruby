module DockerEngine
  module Models
    type volume =
      {
        driver: String,
        labels: ::Hash[Symbol, String],
        mountpoint: String,
        name: String,
        options: ::Hash[Symbol, String],
        scope: DockerEngine::Models::Volume::scope,
        cluster_volume: DockerEngine::Volume::ClusterVolume,
        created_at: String,
        status: ::Hash[Symbol, top],
        usage_data: DockerEngine::Volume::UsageData?
      }

    class Volume < DockerEngine::Internal::Type::BaseModel
      attr_accessor driver: String

      attr_accessor labels: ::Hash[Symbol, String]

      attr_accessor mountpoint: String

      attr_accessor name: String

      attr_accessor options: ::Hash[Symbol, String]

      attr_accessor scope: DockerEngine::Models::Volume::scope

      attr_reader cluster_volume: DockerEngine::Volume::ClusterVolume?

      def cluster_volume=: (
        DockerEngine::Volume::ClusterVolume
      ) -> DockerEngine::Volume::ClusterVolume

      attr_reader created_at: String?

      def created_at=: (String) -> String

      attr_reader status: ::Hash[Symbol, top]?

      def status=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

      attr_accessor usage_data: DockerEngine::Volume::UsageData?

      def initialize: (
        driver: String,
        labels: ::Hash[Symbol, String],
        mountpoint: String,
        name: String,
        options: ::Hash[Symbol, String],
        scope: DockerEngine::Models::Volume::scope,
        ?cluster_volume: DockerEngine::Volume::ClusterVolume,
        ?created_at: String,
        ?status: ::Hash[Symbol, top],
        ?usage_data: DockerEngine::Volume::UsageData?
      ) -> void

      def to_hash: -> {
        driver: String,
        labels: ::Hash[Symbol, String],
        mountpoint: String,
        name: String,
        options: ::Hash[Symbol, String],
        scope: DockerEngine::Models::Volume::scope,
        cluster_volume: DockerEngine::Volume::ClusterVolume,
        created_at: String,
        status: ::Hash[Symbol, top],
        usage_data: DockerEngine::Volume::UsageData?
      }

      type scope = :local | :global

      module Scope
        extend DockerEngine::Internal::Type::Enum

        LOCAL: :local
        GLOBAL: :global

        def self?.values: -> ::Array[DockerEngine::Models::Volume::scope]
      end

      type cluster_volume =
        {
          created_at: String,
          id: String,
          info: DockerEngine::Volume::ClusterVolume::Info,
          publish_status: ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus],
          spec: DockerEngine::Volume::ClusterVolume::Spec,
          updated_at: String,
          version: DockerEngine::Volume::ClusterVolume::Version
        }

      class ClusterVolume < DockerEngine::Internal::Type::BaseModel
        attr_reader created_at: String?

        def created_at=: (String) -> String

        attr_reader id: String?

        def id=: (String) -> String

        attr_reader info: DockerEngine::Volume::ClusterVolume::Info?

        def info=: (
          DockerEngine::Volume::ClusterVolume::Info
        ) -> DockerEngine::Volume::ClusterVolume::Info

        attr_reader publish_status: ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus]?

        def publish_status=: (
          ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus]
        ) -> ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus]

        attr_reader spec: DockerEngine::Volume::ClusterVolume::Spec?

        def spec=: (
          DockerEngine::Volume::ClusterVolume::Spec
        ) -> DockerEngine::Volume::ClusterVolume::Spec

        attr_reader updated_at: String?

        def updated_at=: (String) -> String

        attr_reader version: DockerEngine::Volume::ClusterVolume::Version?

        def version=: (
          DockerEngine::Volume::ClusterVolume::Version
        ) -> DockerEngine::Volume::ClusterVolume::Version

        def initialize: (
          ?created_at: String,
          ?id: String,
          ?info: DockerEngine::Volume::ClusterVolume::Info,
          ?publish_status: ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus],
          ?spec: DockerEngine::Volume::ClusterVolume::Spec,
          ?updated_at: String,
          ?version: DockerEngine::Volume::ClusterVolume::Version
        ) -> void

        def to_hash: -> {
          created_at: String,
          id: String,
          info: DockerEngine::Volume::ClusterVolume::Info,
          publish_status: ::Array[DockerEngine::Volume::ClusterVolume::PublishStatus],
          spec: DockerEngine::Volume::ClusterVolume::Spec,
          updated_at: String,
          version: DockerEngine::Volume::ClusterVolume::Version
        }

        type info =
          {
            accessible_topology: ::Array[::Hash[Symbol, String]],
            capacity_bytes: Integer,
            volume_context: ::Hash[Symbol, String],
            volume_id: String
          }

        class Info < DockerEngine::Internal::Type::BaseModel
          attr_reader accessible_topology: ::Array[::Hash[Symbol, String]]?

          def accessible_topology=: (
            ::Array[::Hash[Symbol, String]]
          ) -> ::Array[::Hash[Symbol, String]]

          attr_reader capacity_bytes: Integer?

          def capacity_bytes=: (Integer) -> Integer

          attr_reader volume_context: ::Hash[Symbol, String]?

          def volume_context=: (
            ::Hash[Symbol, String]
          ) -> ::Hash[Symbol, String]

          attr_reader volume_id: String?

          def volume_id=: (String) -> String

          def initialize: (
            ?accessible_topology: ::Array[::Hash[Symbol, String]],
            ?capacity_bytes: Integer,
            ?volume_context: ::Hash[Symbol, String],
            ?volume_id: String
          ) -> void

          def to_hash: -> {
            accessible_topology: ::Array[::Hash[Symbol, String]],
            capacity_bytes: Integer,
            volume_context: ::Hash[Symbol, String],
            volume_id: String
          }
        end

        type publish_status =
          {
            node_id: String,
            publish_context: ::Hash[Symbol, String],
            state: DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state
          }

        class PublishStatus < DockerEngine::Internal::Type::BaseModel
          attr_reader node_id: String?

          def node_id=: (String) -> String

          attr_reader publish_context: ::Hash[Symbol, String]?

          def publish_context=: (
            ::Hash[Symbol, String]
          ) -> ::Hash[Symbol, String]

          attr_reader state: DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state?

          def state=: (
            DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state
          ) -> DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state

          def initialize: (
            ?node_id: String,
            ?publish_context: ::Hash[Symbol, String],
            ?state: DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state
          ) -> void

          def to_hash: -> {
            node_id: String,
            publish_context: ::Hash[Symbol, String],
            state: DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state
          }

          type state =
            :"pending-publish"
            | :published
            | :"pending-node-unpublish"
            | :"pending-controller-unpublish"

          module State
            extend DockerEngine::Internal::Type::Enum

            PENDING_PUBLISH: :"pending-publish"
            PUBLISHED: :published
            PENDING_NODE_UNPUBLISH: :"pending-node-unpublish"
            PENDING_CONTROLLER_UNPUBLISH: :"pending-controller-unpublish"

            def self?.values: -> ::Array[DockerEngine::Models::Volume::ClusterVolume::PublishStatus::state]
          end
        end

        type spec =
          {
            access_mode: DockerEngine::Volume::ClusterVolume::Spec::AccessMode,
            group: String
          }

        class Spec < DockerEngine::Internal::Type::BaseModel
          attr_reader access_mode: DockerEngine::Volume::ClusterVolume::Spec::AccessMode?

          def access_mode=: (
            DockerEngine::Volume::ClusterVolume::Spec::AccessMode
          ) -> DockerEngine::Volume::ClusterVolume::Spec::AccessMode

          attr_reader group: String?

          def group=: (String) -> String

          def initialize: (
            ?access_mode: DockerEngine::Volume::ClusterVolume::Spec::AccessMode,
            ?group: String
          ) -> void

          def to_hash: -> {
            access_mode: DockerEngine::Volume::ClusterVolume::Spec::AccessMode,
            group: String
          }

          type access_mode =
            {
              accessibility_requirements: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements,
              availability: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability,
              capacity_range: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange,
              mount_volume: top,
              scope: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope,
              secrets: ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret],
              sharing: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing
            }

          class AccessMode < DockerEngine::Internal::Type::BaseModel
            attr_reader accessibility_requirements: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements?

            def accessibility_requirements=: (
              DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements
            ) -> DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements

            attr_reader availability: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability?

            def availability=: (
              DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability
            ) -> DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability

            attr_reader capacity_range: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange?

            def capacity_range=: (
              DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange
            ) -> DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange

            attr_reader mount_volume: top?

            def mount_volume=: (top) -> top

            attr_reader scope: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope?

            def scope=: (
              DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope
            ) -> DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope

            attr_reader secrets: ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret]?

            def secrets=: (
              ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret]
            ) -> ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret]

            attr_reader sharing: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing?

            def sharing=: (
              DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing
            ) -> DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing

            def initialize: (
              ?accessibility_requirements: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements,
              ?availability: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability,
              ?capacity_range: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange,
              ?mount_volume: top,
              ?scope: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope,
              ?secrets: ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret],
              ?sharing: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing
            ) -> void

            def to_hash: -> {
              accessibility_requirements: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::AccessibilityRequirements,
              availability: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability,
              capacity_range: DockerEngine::Volume::ClusterVolume::Spec::AccessMode::CapacityRange,
              mount_volume: top,
              scope: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope,
              secrets: ::Array[DockerEngine::Volume::ClusterVolume::Spec::AccessMode::Secret],
              sharing: DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing
            }

            type accessibility_requirements =
              {
                preferred: ::Array[::Hash[Symbol, String]],
                requisite: ::Array[::Hash[Symbol, String]]
              }

            class AccessibilityRequirements < DockerEngine::Internal::Type::BaseModel
              attr_reader preferred: ::Array[::Hash[Symbol, String]]?

              def preferred=: (
                ::Array[::Hash[Symbol, String]]
              ) -> ::Array[::Hash[Symbol, String]]

              attr_reader requisite: ::Array[::Hash[Symbol, String]]?

              def requisite=: (
                ::Array[::Hash[Symbol, String]]
              ) -> ::Array[::Hash[Symbol, String]]

              def initialize: (
                ?preferred: ::Array[::Hash[Symbol, String]],
                ?requisite: ::Array[::Hash[Symbol, String]]
              ) -> void

              def to_hash: -> {
                preferred: ::Array[::Hash[Symbol, String]],
                requisite: ::Array[::Hash[Symbol, String]]
              }
            end

            type availability = :active | :pause | :drain

            module Availability
              extend DockerEngine::Internal::Type::Enum

              ACTIVE: :active
              PAUSE: :pause
              DRAIN: :drain

              def self?.values: -> ::Array[DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::availability]
            end

            type capacity_range =
              { limit_bytes: Integer, required_bytes: Integer }

            class CapacityRange < DockerEngine::Internal::Type::BaseModel
              attr_reader limit_bytes: Integer?

              def limit_bytes=: (Integer) -> Integer

              attr_reader required_bytes: Integer?

              def required_bytes=: (Integer) -> Integer

              def initialize: (
                ?limit_bytes: Integer,
                ?required_bytes: Integer
              ) -> void

              def to_hash: -> { limit_bytes: Integer, required_bytes: Integer }
            end

            type scope = :single | :multi

            module Scope
              extend DockerEngine::Internal::Type::Enum

              SINGLE: :single
              MULTI: :multi

              def self?.values: -> ::Array[DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::scope]
            end

            type secret = { key: String, secret: String }

            class Secret < DockerEngine::Internal::Type::BaseModel
              attr_reader key: String?

              def key=: (String) -> String

              attr_reader secret: String?

              def secret=: (String) -> String

              def initialize: (?key: String, ?secret: String) -> void

              def to_hash: -> { key: String, secret: String }
            end

            type sharing = :none | :readonly | :onewriter | :all

            module Sharing
              extend DockerEngine::Internal::Type::Enum

              NONE: :none
              READONLY: :readonly
              ONEWRITER: :onewriter
              ALL: :all

              def self?.values: -> ::Array[DockerEngine::Models::Volume::ClusterVolume::Spec::AccessMode::sharing]
            end
          end
        end

        type version = { index: Integer }

        class Version < DockerEngine::Internal::Type::BaseModel
          attr_reader index: Integer?

          def index=: (Integer) -> Integer

          def initialize: (?index: Integer) -> void

          def to_hash: -> { index: Integer }
        end
      end

      type usage_data = { ref_count: Integer, size: Integer }

      class UsageData < DockerEngine::Internal::Type::BaseModel
        attr_accessor ref_count: Integer

        attr_accessor size: Integer

        def initialize: (ref_count: Integer, size: Integer) -> void

        def to_hash: -> { ref_count: Integer, size: Integer }
      end
    end
  end
end
