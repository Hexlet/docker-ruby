module DockerEngine
  module Models
    type network_inspect_response =
      {
        containers: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container],
        services: ::Hash[Symbol, top],
        status: DockerEngine::Models::NetworkInspectResponse::Status
      }

    class NetworkInspectResponse < DockerEngine::Models::Network
      def containers: -> ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container]?

      def containers=: (
        ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container] _
      ) -> ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container]

      def services: -> ::Hash[Symbol, top]?

      def services=: (::Hash[Symbol, top] _) -> ::Hash[Symbol, top]

      def status: -> DockerEngine::Models::NetworkInspectResponse::Status?

      def status=: (
        DockerEngine::Models::NetworkInspectResponse::Status _
      ) -> DockerEngine::Models::NetworkInspectResponse::Status

      def initialize: (
        ?containers: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container],
        ?services: ::Hash[Symbol, top],
        ?status: DockerEngine::Models::NetworkInspectResponse::Status
      ) -> void

      def to_hash: -> {
        containers: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Container],
        services: ::Hash[Symbol, top],
        status: DockerEngine::Models::NetworkInspectResponse::Status
      }

      type container =
        {
          endpoint_id: String,
          :i_pv4_address => String,
          :i_pv6_address => String,
          mac_address: String,
          name: String
        }

      class Container < DockerEngine::Internal::Type::BaseModel
        attr_reader endpoint_id: String?

        def endpoint_id=: (String) -> String

        attr_reader i_pv4_address: String?

        def i_pv4_address=: (String) -> String

        attr_reader i_pv6_address: String?

        def i_pv6_address=: (String) -> String

        attr_reader mac_address: String?

        def mac_address=: (String) -> String

        attr_reader name: String?

        def name=: (String) -> String

        def initialize: (
          ?endpoint_id: String,
          ?i_pv4_address: String,
          ?i_pv6_address: String,
          ?mac_address: String,
          ?name: String
        ) -> void

        def to_hash: -> {
          endpoint_id: String,
          :i_pv4_address => String,
          :i_pv6_address => String,
          mac_address: String,
          name: String
        }
      end

      type status =
        { ipam: DockerEngine::Models::NetworkInspectResponse::Status::Ipam }

      class Status < DockerEngine::Internal::Type::BaseModel
        attr_reader ipam: DockerEngine::Models::NetworkInspectResponse::Status::Ipam?

        def ipam=: (
          DockerEngine::Models::NetworkInspectResponse::Status::Ipam
        ) -> DockerEngine::Models::NetworkInspectResponse::Status::Ipam

        def initialize: (
          ?ipam: DockerEngine::Models::NetworkInspectResponse::Status::Ipam
        ) -> void

        def to_hash: -> {
          ipam: DockerEngine::Models::NetworkInspectResponse::Status::Ipam
        }

        type ipam =
          {
            subnets: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]
          }

        class Ipam < DockerEngine::Internal::Type::BaseModel
          attr_reader subnets: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]?

          def subnets=: (
            ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]
          ) -> ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]

          def initialize: (
            ?subnets: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]
          ) -> void

          def to_hash: -> {
            subnets: ::Hash[Symbol, DockerEngine::Models::NetworkInspectResponse::Status::Ipam::Subnet]
          }

          type subnet = { dynamic_ips_available: Integer, ips_in_use: Integer }

          class Subnet < DockerEngine::Internal::Type::BaseModel
            attr_reader dynamic_ips_available: Integer?

            def dynamic_ips_available=: (Integer) -> Integer

            attr_reader ips_in_use: Integer?

            def ips_in_use=: (Integer) -> Integer

            def initialize: (
              ?dynamic_ips_available: Integer,
              ?ips_in_use: Integer
            ) -> void

            def to_hash: -> {
              dynamic_ips_available: Integer,
              ips_in_use: Integer
            }
          end
        end
      end
    end
  end
end
