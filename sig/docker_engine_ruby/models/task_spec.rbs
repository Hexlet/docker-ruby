module DockerEngineRuby
  module Models
    type task_spec =
      {
        container_spec: DockerEngineRuby::TaskSpec::ContainerSpec,
        force_update: Integer,
        log_driver: DockerEngineRuby::TaskSpec::LogDriver,
        network_attachment_spec: DockerEngineRuby::TaskSpec::NetworkAttachmentSpec,
        networks: ::Array[DockerEngineRuby::TaskSpec::Network],
        placement: DockerEngineRuby::TaskSpec::Placement,
        plugin_spec: DockerEngineRuby::TaskSpec::PluginSpec,
        resources: DockerEngineRuby::TaskSpec::Resources,
        restart_policy: DockerEngineRuby::TaskSpec::RestartPolicy,
        runtime: String
      }

    class TaskSpec < DockerEngineRuby::Internal::Type::BaseModel
      attr_reader container_spec: DockerEngineRuby::TaskSpec::ContainerSpec?

      def container_spec=: (
        DockerEngineRuby::TaskSpec::ContainerSpec
      ) -> DockerEngineRuby::TaskSpec::ContainerSpec

      attr_reader force_update: Integer?

      def force_update=: (Integer) -> Integer

      attr_reader log_driver: DockerEngineRuby::TaskSpec::LogDriver?

      def log_driver=: (
        DockerEngineRuby::TaskSpec::LogDriver
      ) -> DockerEngineRuby::TaskSpec::LogDriver

      attr_reader network_attachment_spec: DockerEngineRuby::TaskSpec::NetworkAttachmentSpec?

      def network_attachment_spec=: (
        DockerEngineRuby::TaskSpec::NetworkAttachmentSpec
      ) -> DockerEngineRuby::TaskSpec::NetworkAttachmentSpec

      attr_reader networks: ::Array[DockerEngineRuby::TaskSpec::Network]?

      def networks=: (
        ::Array[DockerEngineRuby::TaskSpec::Network]
      ) -> ::Array[DockerEngineRuby::TaskSpec::Network]

      attr_reader placement: DockerEngineRuby::TaskSpec::Placement?

      def placement=: (
        DockerEngineRuby::TaskSpec::Placement
      ) -> DockerEngineRuby::TaskSpec::Placement

      attr_reader plugin_spec: DockerEngineRuby::TaskSpec::PluginSpec?

      def plugin_spec=: (
        DockerEngineRuby::TaskSpec::PluginSpec
      ) -> DockerEngineRuby::TaskSpec::PluginSpec

      attr_reader resources: DockerEngineRuby::TaskSpec::Resources?

      def resources=: (
        DockerEngineRuby::TaskSpec::Resources
      ) -> DockerEngineRuby::TaskSpec::Resources

      attr_reader restart_policy: DockerEngineRuby::TaskSpec::RestartPolicy?

      def restart_policy=: (
        DockerEngineRuby::TaskSpec::RestartPolicy
      ) -> DockerEngineRuby::TaskSpec::RestartPolicy

      attr_reader runtime: String?

      def runtime=: (String) -> String

      def initialize: (
        ?container_spec: DockerEngineRuby::TaskSpec::ContainerSpec,
        ?force_update: Integer,
        ?log_driver: DockerEngineRuby::TaskSpec::LogDriver,
        ?network_attachment_spec: DockerEngineRuby::TaskSpec::NetworkAttachmentSpec,
        ?networks: ::Array[DockerEngineRuby::TaskSpec::Network],
        ?placement: DockerEngineRuby::TaskSpec::Placement,
        ?plugin_spec: DockerEngineRuby::TaskSpec::PluginSpec,
        ?resources: DockerEngineRuby::TaskSpec::Resources,
        ?restart_policy: DockerEngineRuby::TaskSpec::RestartPolicy,
        ?runtime: String
      ) -> void

      def to_hash: -> {
        container_spec: DockerEngineRuby::TaskSpec::ContainerSpec,
        force_update: Integer,
        log_driver: DockerEngineRuby::TaskSpec::LogDriver,
        network_attachment_spec: DockerEngineRuby::TaskSpec::NetworkAttachmentSpec,
        networks: ::Array[DockerEngineRuby::TaskSpec::Network],
        placement: DockerEngineRuby::TaskSpec::Placement,
        plugin_spec: DockerEngineRuby::TaskSpec::PluginSpec,
        resources: DockerEngineRuby::TaskSpec::Resources,
        restart_policy: DockerEngineRuby::TaskSpec::RestartPolicy,
        runtime: String
      }

      type container_spec =
        {
          args: ::Array[String],
          capability_add: ::Array[String],
          capability_drop: ::Array[String],
          command: ::Array[String],
          configs: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config],
          dir: String,
          dns_config: DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig,
          env: ::Array[String],
          groups: ::Array[String],
          health_check: DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck,
          hostname: String,
          hosts: ::Array[String],
          image: String,
          init: bool?,
          isolation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation,
          labels: ::Hash[Symbol, String],
          mounts: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount],
          oom_score_adj: Integer,
          open_stdin: bool,
          privileges: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges,
          read_only: bool,
          secrets: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret],
          stop_grace_period: Integer,
          stop_signal: String,
          sysctls: ::Hash[Symbol, String],
          tty: bool,
          ulimits: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit],
          user: String
        }

      class ContainerSpec < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader args: ::Array[String]?

        def args=: (::Array[String]) -> ::Array[String]

        attr_reader capability_add: ::Array[String]?

        def capability_add=: (::Array[String]) -> ::Array[String]

        attr_reader capability_drop: ::Array[String]?

        def capability_drop=: (::Array[String]) -> ::Array[String]

        attr_reader command: ::Array[String]?

        def command=: (::Array[String]) -> ::Array[String]

        attr_reader configs: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config]?

        def configs=: (
          ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config]
        ) -> ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config]

        attr_reader dir: String?

        def dir=: (String) -> String

        attr_reader dns_config: DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig?

        def dns_config=: (
          DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig
        ) -> DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig

        attr_reader env: ::Array[String]?

        def env=: (::Array[String]) -> ::Array[String]

        attr_reader groups: ::Array[String]?

        def groups=: (::Array[String]) -> ::Array[String]

        attr_reader health_check: DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck?

        def health_check=: (
          DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck
        ) -> DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck

        attr_reader hostname: String?

        def hostname=: (String) -> String

        attr_reader hosts: ::Array[String]?

        def hosts=: (::Array[String]) -> ::Array[String]

        attr_reader image: String?

        def image=: (String) -> String

        attr_accessor init: bool?

        attr_reader isolation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation?

        def isolation=: (
          DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation
        ) -> DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation

        attr_reader labels: ::Hash[Symbol, String]?

        def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_reader mounts: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount]?

        def mounts=: (
          ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount]
        ) -> ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount]

        attr_reader oom_score_adj: Integer?

        def oom_score_adj=: (Integer) -> Integer

        attr_reader open_stdin: bool?

        def open_stdin=: (bool) -> bool

        attr_reader privileges: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges?

        def privileges=: (
          DockerEngineRuby::TaskSpec::ContainerSpec::Privileges
        ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Privileges

        attr_reader read_only: bool?

        def read_only=: (bool) -> bool

        attr_reader secrets: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret]?

        def secrets=: (
          ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret]
        ) -> ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret]

        attr_reader stop_grace_period: Integer?

        def stop_grace_period=: (Integer) -> Integer

        attr_reader stop_signal: String?

        def stop_signal=: (String) -> String

        attr_reader sysctls: ::Hash[Symbol, String]?

        def sysctls=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_reader tty: bool?

        def tty=: (bool) -> bool

        attr_reader ulimits: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit]?

        def ulimits=: (
          ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit]
        ) -> ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit]

        attr_reader user: String?

        def user=: (String) -> String

        def initialize: (
          ?args: ::Array[String],
          ?capability_add: ::Array[String],
          ?capability_drop: ::Array[String],
          ?command: ::Array[String],
          ?configs: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config],
          ?dir: String,
          ?dns_config: DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig,
          ?env: ::Array[String],
          ?groups: ::Array[String],
          ?health_check: DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck,
          ?hostname: String,
          ?hosts: ::Array[String],
          ?image: String,
          ?init: bool?,
          ?isolation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation,
          ?labels: ::Hash[Symbol, String],
          ?mounts: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount],
          ?oom_score_adj: Integer,
          ?open_stdin: bool,
          ?privileges: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges,
          ?read_only: bool,
          ?secrets: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret],
          ?stop_grace_period: Integer,
          ?stop_signal: String,
          ?sysctls: ::Hash[Symbol, String],
          ?tty: bool,
          ?ulimits: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit],
          ?user: String
        ) -> void

        def to_hash: -> {
          args: ::Array[String],
          capability_add: ::Array[String],
          capability_drop: ::Array[String],
          command: ::Array[String],
          configs: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Config],
          dir: String,
          dns_config: DockerEngineRuby::TaskSpec::ContainerSpec::DNSConfig,
          env: ::Array[String],
          groups: ::Array[String],
          health_check: DockerEngineRuby::TaskSpec::ContainerSpec::HealthCheck,
          hostname: String,
          hosts: ::Array[String],
          image: String,
          init: bool?,
          isolation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation,
          labels: ::Hash[Symbol, String],
          mounts: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Mount],
          oom_score_adj: Integer,
          open_stdin: bool,
          privileges: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges,
          read_only: bool,
          secrets: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Secret],
          stop_grace_period: Integer,
          stop_signal: String,
          sysctls: ::Hash[Symbol, String],
          tty: bool,
          ulimits: ::Array[DockerEngineRuby::TaskSpec::ContainerSpec::Ulimit],
          user: String
        }

        type config =
          {
            config_id: String,
            config_name: String,
            file: DockerEngineRuby::TaskSpec::ContainerSpec::Config::File,
            runtime: ::Hash[Symbol, top]
          }

        class Config < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader config_id: String?

          def config_id=: (String) -> String

          attr_reader config_name: String?

          def config_name=: (String) -> String

          attr_reader file: DockerEngineRuby::TaskSpec::ContainerSpec::Config::File?

          def file=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Config::File
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Config::File

          attr_reader runtime: ::Hash[Symbol, top]?

          def runtime=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

          def initialize: (
            ?config_id: String,
            ?config_name: String,
            ?file: DockerEngineRuby::TaskSpec::ContainerSpec::Config::File,
            ?runtime: ::Hash[Symbol, top]
          ) -> void

          def to_hash: -> {
            config_id: String,
            config_name: String,
            file: DockerEngineRuby::TaskSpec::ContainerSpec::Config::File,
            runtime: ::Hash[Symbol, top]
          }

          type file = { gid: String, mode: Integer, name: String, uid: String }

          class File < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader gid: String?

            def gid=: (String) -> String

            attr_reader mode: Integer?

            def mode=: (Integer) -> Integer

            attr_reader name: String?

            def name=: (String) -> String

            attr_reader uid: String?

            def uid=: (String) -> String

            def initialize: (
              ?gid: String,
              ?mode: Integer,
              ?name: String,
              ?uid: String
            ) -> void

            def to_hash: -> {
              gid: String,
              mode: Integer,
              name: String,
              uid: String
            }
          end
        end

        type dns_config =
          {
            nameservers: ::Array[String],
            options: ::Array[String],
            search: ::Array[String]
          }

        class DNSConfig < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader nameservers: ::Array[String]?

          def nameservers=: (::Array[String]) -> ::Array[String]

          attr_reader options: ::Array[String]?

          def options=: (::Array[String]) -> ::Array[String]

          attr_reader search: ::Array[String]?

          def search=: (::Array[String]) -> ::Array[String]

          def initialize: (
            ?nameservers: ::Array[String],
            ?options: ::Array[String],
            ?search: ::Array[String]
          ) -> void

          def to_hash: -> {
            nameservers: ::Array[String],
            options: ::Array[String],
            search: ::Array[String]
          }
        end

        type health_check =
          {
            interval: Integer,
            retries: Integer,
            start_interval: Integer,
            start_period: Integer,
            test_: ::Array[String],
            timeout: Integer
          }

        class HealthCheck < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader interval: Integer?

          def interval=: (Integer) -> Integer

          attr_reader retries: Integer?

          def retries=: (Integer) -> Integer

          attr_reader start_interval: Integer?

          def start_interval=: (Integer) -> Integer

          attr_reader start_period: Integer?

          def start_period=: (Integer) -> Integer

          attr_reader test_: ::Array[String]?

          def test_=: (::Array[String]) -> ::Array[String]

          attr_reader timeout: Integer?

          def timeout=: (Integer) -> Integer

          def initialize: (
            ?interval: Integer,
            ?retries: Integer,
            ?start_interval: Integer,
            ?start_period: Integer,
            ?test_: ::Array[String],
            ?timeout: Integer
          ) -> void

          def to_hash: -> {
            interval: Integer,
            retries: Integer,
            start_interval: Integer,
            start_period: Integer,
            test_: ::Array[String],
            timeout: Integer
          }
        end

        type isolation = :default | :process | :hyperv | :""

        module Isolation
          extend DockerEngineRuby::Internal::Type::Enum

          DEFAULT: :default
          PROCESS: :process
          HYPERV: :hyperv
          EMPTY: :""

          def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::ContainerSpec::isolation]
        end

        type mount =
          {
            bind_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions,
            consistency: String,
            image_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions,
            read_only: bool,
            source: String,
            target: String,
            tmpfs_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions,
            type: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_,
            volume_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions
          }

        class Mount < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader bind_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions?

          def bind_options=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions

          attr_reader consistency: String?

          def consistency=: (String) -> String

          attr_reader image_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions?

          def image_options=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions

          attr_reader read_only: bool?

          def read_only=: (bool) -> bool

          attr_reader source: String?

          def source=: (String) -> String

          attr_reader target: String?

          def target=: (String) -> String

          attr_reader tmpfs_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions?

          def tmpfs_options=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions

          attr_reader type: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_?

          def type=: (
            DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_
          ) -> DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_

          attr_reader volume_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions?

          def volume_options=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions

          def initialize: (
            ?bind_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions,
            ?consistency: String,
            ?image_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions,
            ?read_only: bool,
            ?source: String,
            ?target: String,
            ?tmpfs_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions,
            ?type: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_,
            ?volume_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions
          ) -> void

          def to_hash: -> {
            bind_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::BindOptions,
            consistency: String,
            image_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::ImageOptions,
            read_only: bool,
            source: String,
            target: String,
            tmpfs_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::TmpfsOptions,
            type: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_,
            volume_options: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions
          }

          type bind_options =
            {
              create_mountpoint: bool,
              non_recursive: bool,
              propagation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation,
              read_only_force_recursive: bool,
              read_only_non_recursive: bool
            }

          class BindOptions < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader create_mountpoint: bool?

            def create_mountpoint=: (bool) -> bool

            attr_reader non_recursive: bool?

            def non_recursive=: (bool) -> bool

            attr_reader propagation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation?

            def propagation=: (
              DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation
            ) -> DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation

            attr_reader read_only_force_recursive: bool?

            def read_only_force_recursive=: (bool) -> bool

            attr_reader read_only_non_recursive: bool?

            def read_only_non_recursive=: (bool) -> bool

            def initialize: (
              ?create_mountpoint: bool,
              ?non_recursive: bool,
              ?propagation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation,
              ?read_only_force_recursive: bool,
              ?read_only_non_recursive: bool
            ) -> void

            def to_hash: -> {
              create_mountpoint: bool,
              non_recursive: bool,
              propagation: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation,
              read_only_force_recursive: bool,
              read_only_non_recursive: bool
            }

            type propagation =
              :private | :rprivate | :shared | :rshared | :slave | :rslave

            module Propagation
              extend DockerEngineRuby::Internal::Type::Enum

              PRIVATE: :private
              RPRIVATE: :rprivate
              SHARED: :shared
              RSHARED: :rshared
              SLAVE: :slave
              RSLAVE: :rslave

              def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::BindOptions::propagation]
            end
          end

          type image_options = { subpath: String }

          class ImageOptions < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader subpath: String?

            def subpath=: (String) -> String

            def initialize: (?subpath: String) -> void

            def to_hash: -> { subpath: String }
          end

          type tmpfs_options =
            {
              mode: Integer,
              options: ::Array[::Array[String]],
              size_bytes: Integer
            }

          class TmpfsOptions < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader mode: Integer?

            def mode=: (Integer) -> Integer

            attr_reader options: ::Array[::Array[String]]?

            def options=: (::Array[::Array[String]]) -> ::Array[::Array[String]]

            attr_reader size_bytes: Integer?

            def size_bytes=: (Integer) -> Integer

            def initialize: (
              ?mode: Integer,
              ?options: ::Array[::Array[String]],
              ?size_bytes: Integer
            ) -> void

            def to_hash: -> {
              mode: Integer,
              options: ::Array[::Array[String]],
              size_bytes: Integer
            }
          end

          type type_ = :bind | :cluster | :image | :npipe | :tmpfs | :volume

          module Type
            extend DockerEngineRuby::Internal::Type::Enum

            BIND: :bind
            CLUSTER: :cluster
            IMAGE: :image
            NPIPE: :npipe
            TMPFS: :tmpfs
            VOLUME: :volume

            def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::ContainerSpec::Mount::type_]
          end

          type volume_options =
            {
              driver_config: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig,
              labels: ::Hash[Symbol, String],
              no_copy: bool,
              subpath: String
            }

          class VolumeOptions < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader driver_config: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig?

            def driver_config=: (
              DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig
            ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig

            attr_reader labels: ::Hash[Symbol, String]?

            def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

            attr_reader no_copy: bool?

            def no_copy=: (bool) -> bool

            attr_reader subpath: String?

            def subpath=: (String) -> String

            def initialize: (
              ?driver_config: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig,
              ?labels: ::Hash[Symbol, String],
              ?no_copy: bool,
              ?subpath: String
            ) -> void

            def to_hash: -> {
              driver_config: DockerEngineRuby::TaskSpec::ContainerSpec::Mount::VolumeOptions::DriverConfig,
              labels: ::Hash[Symbol, String],
              no_copy: bool,
              subpath: String
            }

            type driver_config =
              { name: String, options: ::Hash[Symbol, String] }

            class DriverConfig < DockerEngineRuby::Internal::Type::BaseModel
              attr_reader name: String?

              def name=: (String) -> String

              attr_reader options: ::Hash[Symbol, String]?

              def options=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

              def initialize: (
                ?name: String,
                ?options: ::Hash[Symbol, String]
              ) -> void

              def to_hash: -> { name: String, options: ::Hash[Symbol, String] }
            end
          end
        end

        type privileges =
          {
            app_armor: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor,
            credential_spec: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec,
            no_new_privileges: bool,
            seccomp: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp,
            se_linux_context: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext
          }

        class Privileges < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader app_armor: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor?

          def app_armor=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor

          attr_reader credential_spec: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec?

          def credential_spec=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec

          attr_reader no_new_privileges: bool?

          def no_new_privileges=: (bool) -> bool

          attr_reader seccomp: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp?

          def seccomp=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp

          attr_reader se_linux_context: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext?

          def se_linux_context=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext

          def initialize: (
            ?app_armor: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor,
            ?credential_spec: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec,
            ?no_new_privileges: bool,
            ?seccomp: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp,
            ?se_linux_context: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext
          ) -> void

          def to_hash: -> {
            app_armor: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::AppArmor,
            credential_spec: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::CredentialSpec,
            no_new_privileges: bool,
            seccomp: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::Seccomp,
            se_linux_context: DockerEngineRuby::TaskSpec::ContainerSpec::Privileges::SeLinuxContext
          }

          type app_armor =
            {
              mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode
            }

          class AppArmor < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode?

            def mode=: (
              DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode
            ) -> DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode

            def initialize: (
              ?mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode
            ) -> void

            def to_hash: -> {
              mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode
            }

            type mode = :default | :disabled

            module Mode
              extend DockerEngineRuby::Internal::Type::Enum

              DEFAULT: :default
              DISABLED: :disabled

              def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::AppArmor::mode]
            end
          end

          type credential_spec =
            { config: String, file: String, registry: String }

          class CredentialSpec < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader config: String?

            def config=: (String) -> String

            attr_reader file: String?

            def file=: (String) -> String

            attr_reader registry: String?

            def registry=: (String) -> String

            def initialize: (
              ?config: String,
              ?file: String,
              ?registry: String
            ) -> void

            def to_hash: -> { config: String, file: String, registry: String }
          end

          type seccomp =
            {
              mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode,
              profile: String
            }

          class Seccomp < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode?

            def mode=: (
              DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode
            ) -> DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode

            attr_reader profile: String?

            def profile=: (String) -> String

            def initialize: (
              ?mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode,
              ?profile: String
            ) -> void

            def to_hash: -> {
              mode: DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode,
              profile: String
            }

            type mode = :default | :unconfined | :custom

            module Mode
              extend DockerEngineRuby::Internal::Type::Enum

              DEFAULT: :default
              UNCONFINED: :unconfined
              CUSTOM: :custom

              def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::ContainerSpec::Privileges::Seccomp::mode]
            end
          end

          type se_linux_context =
            {
              disable: bool,
              level: String,
              role: String,
              type: String,
              user: String
            }

          class SeLinuxContext < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader disable: bool?

            def disable=: (bool) -> bool

            attr_reader level: String?

            def level=: (String) -> String

            attr_reader role: String?

            def role=: (String) -> String

            attr_reader type: String?

            def type=: (String) -> String

            attr_reader user: String?

            def user=: (String) -> String

            def initialize: (
              ?disable: bool,
              ?level: String,
              ?role: String,
              ?type: String,
              ?user: String
            ) -> void

            def to_hash: -> {
              disable: bool,
              level: String,
              role: String,
              type: String,
              user: String
            }
          end
        end

        type secret =
          {
            file: DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File,
            secret_id: String,
            secret_name: String
          }

        class Secret < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader file: DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File?

          def file=: (
            DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File
          ) -> DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File

          attr_reader secret_id: String?

          def secret_id=: (String) -> String

          attr_reader secret_name: String?

          def secret_name=: (String) -> String

          def initialize: (
            ?file: DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File,
            ?secret_id: String,
            ?secret_name: String
          ) -> void

          def to_hash: -> {
            file: DockerEngineRuby::TaskSpec::ContainerSpec::Secret::File,
            secret_id: String,
            secret_name: String
          }

          type file = { gid: String, mode: Integer, name: String, uid: String }

          class File < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader gid: String?

            def gid=: (String) -> String

            attr_reader mode: Integer?

            def mode=: (Integer) -> Integer

            attr_reader name: String?

            def name=: (String) -> String

            attr_reader uid: String?

            def uid=: (String) -> String

            def initialize: (
              ?gid: String,
              ?mode: Integer,
              ?name: String,
              ?uid: String
            ) -> void

            def to_hash: -> {
              gid: String,
              mode: Integer,
              name: String,
              uid: String
            }
          end
        end

        type ulimit = { hard: Integer, name: String, soft: Integer }

        class Ulimit < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader hard: Integer?

          def hard=: (Integer) -> Integer

          attr_reader name: String?

          def name=: (String) -> String

          attr_reader soft: Integer?

          def soft=: (Integer) -> Integer

          def initialize: (
            ?hard: Integer,
            ?name: String,
            ?soft: Integer
          ) -> void

          def to_hash: -> { hard: Integer, name: String, soft: Integer }
        end
      end

      type log_driver = { name: String, options: ::Hash[Symbol, String] }

      class LogDriver < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader name: String?

        def name=: (String) -> String

        attr_reader options: ::Hash[Symbol, String]?

        def options=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        def initialize: (
          ?name: String,
          ?options: ::Hash[Symbol, String]
        ) -> void

        def to_hash: -> { name: String, options: ::Hash[Symbol, String] }
      end

      type network_attachment_spec = { container_id: String }

      class NetworkAttachmentSpec < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader container_id: String?

        def container_id=: (String) -> String

        def initialize: (?container_id: String) -> void

        def to_hash: -> { container_id: String }
      end

      type network =
        {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }

      class Network < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader aliases: ::Array[String]?

        def aliases=: (::Array[String]) -> ::Array[String]

        attr_reader driver_opts: ::Hash[Symbol, String]?

        def driver_opts=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_reader target: String?

        def target=: (String) -> String

        def initialize: (
          ?aliases: ::Array[String],
          ?driver_opts: ::Hash[Symbol, String],
          ?target: String
        ) -> void

        def to_hash: -> {
          aliases: ::Array[String],
          driver_opts: ::Hash[Symbol, String],
          target: String
        }
      end

      type placement =
        {
          constraints: ::Array[String],
          max_replicas: Integer,
          platforms: ::Array[DockerEngineRuby::TaskSpec::Placement::Platform],
          preferences: ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]
        }

      class Placement < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader constraints: ::Array[String]?

        def constraints=: (::Array[String]) -> ::Array[String]

        attr_reader max_replicas: Integer?

        def max_replicas=: (Integer) -> Integer

        attr_reader platforms: ::Array[DockerEngineRuby::TaskSpec::Placement::Platform]?

        def platforms=: (
          ::Array[DockerEngineRuby::TaskSpec::Placement::Platform]
        ) -> ::Array[DockerEngineRuby::TaskSpec::Placement::Platform]

        attr_reader preferences: ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]?

        def preferences=: (
          ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]
        ) -> ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]

        def initialize: (
          ?constraints: ::Array[String],
          ?max_replicas: Integer,
          ?platforms: ::Array[DockerEngineRuby::TaskSpec::Placement::Platform],
          ?preferences: ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]
        ) -> void

        def to_hash: -> {
          constraints: ::Array[String],
          max_replicas: Integer,
          platforms: ::Array[DockerEngineRuby::TaskSpec::Placement::Platform],
          preferences: ::Array[DockerEngineRuby::TaskSpec::Placement::Preference]
        }

        type platform = { architecture: String, os: String }

        class Platform < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader architecture: String?

          def architecture=: (String) -> String

          attr_reader os: String?

          def os=: (String) -> String

          def initialize: (?architecture: String, ?os: String) -> void

          def to_hash: -> { architecture: String, os: String }
        end

        type preference =
          { spread: DockerEngineRuby::TaskSpec::Placement::Preference::Spread }

        class Preference < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader spread: DockerEngineRuby::TaskSpec::Placement::Preference::Spread?

          def spread=: (
            DockerEngineRuby::TaskSpec::Placement::Preference::Spread
          ) -> DockerEngineRuby::TaskSpec::Placement::Preference::Spread

          def initialize: (
            ?spread: DockerEngineRuby::TaskSpec::Placement::Preference::Spread
          ) -> void

          def to_hash: -> {
            spread: DockerEngineRuby::TaskSpec::Placement::Preference::Spread
          }

          type spread = { spread_descriptor: String }

          class Spread < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader spread_descriptor: String?

            def spread_descriptor=: (String) -> String

            def initialize: (?spread_descriptor: String) -> void

            def to_hash: -> { spread_descriptor: String }
          end
        end
      end

      type plugin_spec =
        {
          disabled: bool,
          name: String,
          plugin_privilege: ::Array[DockerEngineRuby::Privilege],
          remote: String
        }

      class PluginSpec < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader disabled: bool?

        def disabled=: (bool) -> bool

        attr_reader name: String?

        def name=: (String) -> String

        attr_reader plugin_privilege: ::Array[DockerEngineRuby::Privilege]?

        def plugin_privilege=: (
          ::Array[DockerEngineRuby::Privilege]
        ) -> ::Array[DockerEngineRuby::Privilege]

        attr_reader remote: String?

        def remote=: (String) -> String

        def initialize: (
          ?disabled: bool,
          ?name: String,
          ?plugin_privilege: ::Array[DockerEngineRuby::Privilege],
          ?remote: String
        ) -> void

        def to_hash: -> {
          disabled: bool,
          name: String,
          plugin_privilege: ::Array[DockerEngineRuby::Privilege],
          remote: String
        }
      end

      type resources =
        {
          limits: DockerEngineRuby::TaskSpec::Resources::Limits,
          memory_swappiness: Integer?,
          reservations: DockerEngineRuby::TaskSpec::Resources::Reservations,
          swap_bytes: Integer?
        }

      class Resources < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader limits: DockerEngineRuby::TaskSpec::Resources::Limits?

        def limits=: (
          DockerEngineRuby::TaskSpec::Resources::Limits
        ) -> DockerEngineRuby::TaskSpec::Resources::Limits

        attr_accessor memory_swappiness: Integer?

        attr_reader reservations: DockerEngineRuby::TaskSpec::Resources::Reservations?

        def reservations=: (
          DockerEngineRuby::TaskSpec::Resources::Reservations
        ) -> DockerEngineRuby::TaskSpec::Resources::Reservations

        attr_accessor swap_bytes: Integer?

        def initialize: (
          ?limits: DockerEngineRuby::TaskSpec::Resources::Limits,
          ?memory_swappiness: Integer?,
          ?reservations: DockerEngineRuby::TaskSpec::Resources::Reservations,
          ?swap_bytes: Integer?
        ) -> void

        def to_hash: -> {
          limits: DockerEngineRuby::TaskSpec::Resources::Limits,
          memory_swappiness: Integer?,
          reservations: DockerEngineRuby::TaskSpec::Resources::Reservations,
          swap_bytes: Integer?
        }

        type limits =
          { memory_bytes: Integer, nano_cpus: Integer, pids: Integer }

        class Limits < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader memory_bytes: Integer?

          def memory_bytes=: (Integer) -> Integer

          attr_reader nano_cpus: Integer?

          def nano_cpus=: (Integer) -> Integer

          attr_reader pids: Integer?

          def pids=: (Integer) -> Integer

          def initialize: (
            ?memory_bytes: Integer,
            ?nano_cpus: Integer,
            ?pids: Integer
          ) -> void

          def to_hash: -> {
            memory_bytes: Integer,
            nano_cpus: Integer,
            pids: Integer
          }
        end

        type reservations =
          {
            generic_resources: ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource],
            memory_bytes: Integer,
            nano_cpus: Integer
          }

        class Reservations < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader generic_resources: ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource]?

          def generic_resources=: (
            ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource]
          ) -> ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource]

          attr_reader memory_bytes: Integer?

          def memory_bytes=: (Integer) -> Integer

          attr_reader nano_cpus: Integer?

          def nano_cpus=: (Integer) -> Integer

          def initialize: (
            ?generic_resources: ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource],
            ?memory_bytes: Integer,
            ?nano_cpus: Integer
          ) -> void

          def to_hash: -> {
            generic_resources: ::Array[DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource],
            memory_bytes: Integer,
            nano_cpus: Integer
          }

          type generic_resource =
            {
              discrete_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec,
              named_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec
            }

          class GenericResource < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader discrete_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec?

            def discrete_resource_spec=: (
              DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec
            ) -> DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec

            attr_reader named_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec?

            def named_resource_spec=: (
              DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec
            ) -> DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec

            def initialize: (
              ?discrete_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec,
              ?named_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec
            ) -> void

            def to_hash: -> {
              discrete_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::DiscreteResourceSpec,
              named_resource_spec: DockerEngineRuby::TaskSpec::Resources::Reservations::GenericResource::NamedResourceSpec
            }

            type discrete_resource_spec = { kind: String, value: Integer }

            class DiscreteResourceSpec < DockerEngineRuby::Internal::Type::BaseModel
              attr_reader kind: String?

              def kind=: (String) -> String

              attr_reader value: Integer?

              def value=: (Integer) -> Integer

              def initialize: (?kind: String, ?value: Integer) -> void

              def to_hash: -> { kind: String, value: Integer }
            end

            type named_resource_spec = { kind: String, value: String }

            class NamedResourceSpec < DockerEngineRuby::Internal::Type::BaseModel
              attr_reader kind: String?

              def kind=: (String) -> String

              attr_reader value: String?

              def value=: (String) -> String

              def initialize: (?kind: String, ?value: String) -> void

              def to_hash: -> { kind: String, value: String }
            end
          end
        end
      end

      type restart_policy =
        {
          condition: DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition,
          delay: Integer,
          max_attempts: Integer,
          window: Integer
        }

      class RestartPolicy < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader condition: DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition?

        def condition=: (
          DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition
        ) -> DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition

        attr_reader delay: Integer?

        def delay=: (Integer) -> Integer

        attr_reader max_attempts: Integer?

        def max_attempts=: (Integer) -> Integer

        attr_reader window: Integer?

        def window=: (Integer) -> Integer

        def initialize: (
          ?condition: DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition,
          ?delay: Integer,
          ?max_attempts: Integer,
          ?window: Integer
        ) -> void

        def to_hash: -> {
          condition: DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition,
          delay: Integer,
          max_attempts: Integer,
          window: Integer
        }

        type condition = :none | :"on-failure" | :any

        module Condition
          extend DockerEngineRuby::Internal::Type::Enum

          NONE: :none
          ON_FAILURE: :"on-failure"
          ANY: :any

          def self?.values: -> ::Array[DockerEngineRuby::Models::TaskSpec::RestartPolicy::condition]
        end
      end
    end
  end
end
