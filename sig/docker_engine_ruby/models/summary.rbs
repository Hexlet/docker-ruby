module DockerEngineRuby
  module Models
    type summary =
      {
        command: String,
        created: Integer,
        health: DockerEngineRuby::Summary::Health,
        host_config: DockerEngineRuby::Summary::HostConfig,
        id: String,
        image: String,
        image_id: String,
        image_manifest_descriptor: DockerEngineRuby::Summary::ImageManifestDescriptor?,
        labels: top,
        mounts: ::Array[DockerEngineRuby::Summary::Mount],
        names: ::Array[String],
        network_settings: DockerEngineRuby::Summary::NetworkSettings,
        ports: ::Array[DockerEngineRuby::Summary::Port],
        size_root_fs: Integer?,
        size_rw: Integer?,
        state: DockerEngineRuby::Models::Summary::state,
        status: String
      }

    class Summary < DockerEngineRuby::Internal::Type::BaseModel
      attr_reader command: String?

      def command=: (String) -> String

      attr_reader created: Integer?

      def created=: (Integer) -> Integer

      attr_reader health: DockerEngineRuby::Summary::Health?

      def health=: (
        DockerEngineRuby::Summary::Health
      ) -> DockerEngineRuby::Summary::Health

      attr_reader host_config: DockerEngineRuby::Summary::HostConfig?

      def host_config=: (
        DockerEngineRuby::Summary::HostConfig
      ) -> DockerEngineRuby::Summary::HostConfig

      attr_reader id: String?

      def id=: (String) -> String

      attr_reader image: String?

      def image=: (String) -> String

      attr_reader image_id: String?

      def image_id=: (String) -> String

      attr_accessor image_manifest_descriptor: DockerEngineRuby::Summary::ImageManifestDescriptor?

      attr_reader labels: top?

      def labels=: (top) -> top

      attr_reader mounts: ::Array[DockerEngineRuby::Summary::Mount]?

      def mounts=: (
        ::Array[DockerEngineRuby::Summary::Mount]
      ) -> ::Array[DockerEngineRuby::Summary::Mount]

      attr_reader names: ::Array[String]?

      def names=: (::Array[String]) -> ::Array[String]

      attr_reader network_settings: DockerEngineRuby::Summary::NetworkSettings?

      def network_settings=: (
        DockerEngineRuby::Summary::NetworkSettings
      ) -> DockerEngineRuby::Summary::NetworkSettings

      attr_reader ports: ::Array[DockerEngineRuby::Summary::Port]?

      def ports=: (
        ::Array[DockerEngineRuby::Summary::Port]
      ) -> ::Array[DockerEngineRuby::Summary::Port]

      attr_accessor size_root_fs: Integer?

      attr_accessor size_rw: Integer?

      attr_reader state: DockerEngineRuby::Models::Summary::state?

      def state=: (
        DockerEngineRuby::Models::Summary::state
      ) -> DockerEngineRuby::Models::Summary::state

      attr_reader status: String?

      def status=: (String) -> String

      def initialize: (
        ?command: String,
        ?created: Integer,
        ?health: DockerEngineRuby::Summary::Health,
        ?host_config: DockerEngineRuby::Summary::HostConfig,
        ?id: String,
        ?image: String,
        ?image_id: String,
        ?image_manifest_descriptor: DockerEngineRuby::Summary::ImageManifestDescriptor?,
        ?labels: top,
        ?mounts: ::Array[DockerEngineRuby::Summary::Mount],
        ?names: ::Array[String],
        ?network_settings: DockerEngineRuby::Summary::NetworkSettings,
        ?ports: ::Array[DockerEngineRuby::Summary::Port],
        ?size_root_fs: Integer?,
        ?size_rw: Integer?,
        ?state: DockerEngineRuby::Models::Summary::state,
        ?status: String
      ) -> void

      def to_hash: -> {
        command: String,
        created: Integer,
        health: DockerEngineRuby::Summary::Health,
        host_config: DockerEngineRuby::Summary::HostConfig,
        id: String,
        image: String,
        image_id: String,
        image_manifest_descriptor: DockerEngineRuby::Summary::ImageManifestDescriptor?,
        labels: top,
        mounts: ::Array[DockerEngineRuby::Summary::Mount],
        names: ::Array[String],
        network_settings: DockerEngineRuby::Summary::NetworkSettings,
        ports: ::Array[DockerEngineRuby::Summary::Port],
        size_root_fs: Integer?,
        size_rw: Integer?,
        state: DockerEngineRuby::Models::Summary::state,
        status: String
      }

      type health =
        {
          failing_streak: Integer,
          status: DockerEngineRuby::Models::Summary::Health::status
        }

      class Health < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader failing_streak: Integer?

        def failing_streak=: (Integer) -> Integer

        attr_reader status: DockerEngineRuby::Models::Summary::Health::status?

        def status=: (
          DockerEngineRuby::Models::Summary::Health::status
        ) -> DockerEngineRuby::Models::Summary::Health::status

        def initialize: (
          ?failing_streak: Integer,
          ?status: DockerEngineRuby::Models::Summary::Health::status
        ) -> void

        def to_hash: -> {
          failing_streak: Integer,
          status: DockerEngineRuby::Models::Summary::Health::status
        }

        type status = :none | :starting | :healthy | :unhealthy

        module Status
          extend DockerEngineRuby::Internal::Type::Enum

          NONE: :none
          STARTING: :starting
          HEALTHY: :healthy
          UNHEALTHY: :unhealthy

          def self?.values: -> ::Array[DockerEngineRuby::Models::Summary::Health::status]
        end
      end

      type host_config = { annotations: top?, network_mode: String }

      class HostConfig < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor annotations: top?

        attr_reader network_mode: String?

        def network_mode=: (String) -> String

        def initialize: (?annotations: top?, ?network_mode: String) -> void

        def to_hash: -> { annotations: top?, network_mode: String }
      end

      type image_manifest_descriptor =
        {
          annotations: top?,
          artifact_type: String?,
          data: String?,
          digest: String,
          media_type: String,
          platform: DockerEngineRuby::Summary::ImageManifestDescriptor::Platform,
          size: Integer,
          urls: ::Array[String]?
        }

      class ImageManifestDescriptor < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor annotations: top?

        attr_accessor artifact_type: String?

        attr_accessor data: String?

        attr_reader digest: String?

        def digest=: (String) -> String

        attr_reader media_type: String?

        def media_type=: (String) -> String

        attr_reader platform: DockerEngineRuby::Summary::ImageManifestDescriptor::Platform?

        def platform=: (
          DockerEngineRuby::Summary::ImageManifestDescriptor::Platform
        ) -> DockerEngineRuby::Summary::ImageManifestDescriptor::Platform

        attr_reader size: Integer?

        def size=: (Integer) -> Integer

        attr_accessor urls: ::Array[String]?

        def initialize: (
          ?annotations: top?,
          ?artifact_type: String?,
          ?data: String?,
          ?digest: String,
          ?media_type: String,
          ?platform: DockerEngineRuby::Summary::ImageManifestDescriptor::Platform,
          ?size: Integer,
          ?urls: ::Array[String]?
        ) -> void

        def to_hash: -> {
          annotations: top?,
          artifact_type: String?,
          data: String?,
          digest: String,
          media_type: String,
          platform: DockerEngineRuby::Summary::ImageManifestDescriptor::Platform,
          size: Integer,
          urls: ::Array[String]?
        }

        type platform =
          {
            architecture: String,
            os: String,
            os_features: ::Array[String],
            os_version: String,
            variant: String
          }

        class Platform < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader architecture: String?

          def architecture=: (String) -> String

          attr_reader os: String?

          def os=: (String) -> String

          attr_reader os_features: ::Array[String]?

          def os_features=: (::Array[String]) -> ::Array[String]

          attr_reader os_version: String?

          def os_version=: (String) -> String

          attr_reader variant: String?

          def variant=: (String) -> String

          def initialize: (
            ?architecture: String,
            ?os: String,
            ?os_features: ::Array[String],
            ?os_version: String,
            ?variant: String
          ) -> void

          def to_hash: -> {
            architecture: String,
            os: String,
            os_features: ::Array[String],
            os_version: String,
            variant: String
          }
        end
      end

      type mount =
        {
          destination: String,
          driver: String,
          mode: String,
          name: String,
          propagation: String,
          rw: bool,
          source: String,
          type: DockerEngineRuby::Models::Summary::Mount::type_
        }

      class Mount < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader destination: String?

        def destination=: (String) -> String

        attr_reader driver: String?

        def driver=: (String) -> String

        attr_reader mode: String?

        def mode=: (String) -> String

        attr_reader name: String?

        def name=: (String) -> String

        attr_reader propagation: String?

        def propagation=: (String) -> String

        attr_reader rw: bool?

        def rw=: (bool) -> bool

        attr_reader source: String?

        def source=: (String) -> String

        attr_reader type: DockerEngineRuby::Models::Summary::Mount::type_?

        def type=: (
          DockerEngineRuby::Models::Summary::Mount::type_
        ) -> DockerEngineRuby::Models::Summary::Mount::type_

        def initialize: (
          ?destination: String,
          ?driver: String,
          ?mode: String,
          ?name: String,
          ?propagation: String,
          ?rw: bool,
          ?source: String,
          ?type: DockerEngineRuby::Models::Summary::Mount::type_
        ) -> void

        def to_hash: -> {
          destination: String,
          driver: String,
          mode: String,
          name: String,
          propagation: String,
          rw: bool,
          source: String,
          type: DockerEngineRuby::Models::Summary::Mount::type_
        }

        type type_ = :bind | :cluster | :image | :npipe | :tmpfs | :volume

        module Type
          extend DockerEngineRuby::Internal::Type::Enum

          BIND: :bind
          CLUSTER: :cluster
          IMAGE: :image
          NPIPE: :npipe
          TMPFS: :tmpfs
          VOLUME: :volume

          def self?.values: -> ::Array[DockerEngineRuby::Models::Summary::Mount::type_]
        end
      end

      type network_settings = { networks: top }

      class NetworkSettings < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader networks: top?

        def networks=: (top) -> top

        def initialize: (?networks: top) -> void

        def to_hash: -> { networks: top }
      end

      type port =
        {
          private_port: Integer,
          type: DockerEngineRuby::Models::Summary::Port::type_,
          ip: String,
          public_port: Integer
        }

      class Port < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor private_port: Integer

        attr_accessor type: DockerEngineRuby::Models::Summary::Port::type_

        attr_reader ip: String?

        def ip=: (String) -> String

        attr_reader public_port: Integer?

        def public_port=: (Integer) -> Integer

        def initialize: (
          private_port: Integer,
          type: DockerEngineRuby::Models::Summary::Port::type_,
          ?ip: String,
          ?public_port: Integer
        ) -> void

        def to_hash: -> {
          private_port: Integer,
          type: DockerEngineRuby::Models::Summary::Port::type_,
          ip: String,
          public_port: Integer
        }

        type type_ = :tcp | :udp | :sctp

        module Type
          extend DockerEngineRuby::Internal::Type::Enum

          TCP: :tcp
          UDP: :udp
          SCTP: :sctp

          def self?.values: -> ::Array[DockerEngineRuby::Models::Summary::Port::type_]
        end
      end

      type state =
        :created
        | :running
        | :paused
        | :restarting
        | :exited
        | :removing
        | :dead

      module State
        extend DockerEngineRuby::Internal::Type::Enum

        CREATED: :created
        RUNNING: :running
        PAUSED: :paused
        RESTARTING: :restarting
        EXITED: :exited
        REMOVING: :removing
        DEAD: :dead

        def self?.values: -> ::Array[DockerEngineRuby::Models::Summary::state]
      end
    end
  end
end
