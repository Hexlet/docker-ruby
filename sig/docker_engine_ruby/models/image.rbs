module DockerEngineRuby
  module Models
    type image =
      {
        architecture: String,
        author: String?,
        comment: String?,
        config: DockerEngineRuby::Image::Config,
        created: Time?,
        descriptor: DockerEngineRuby::Image::Descriptor?,
        graph_driver: DockerEngineRuby::Image::GraphDriver?,
        id: String,
        identity: DockerEngineRuby::Image::Identity?,
        manifests: ::Array[DockerEngineRuby::Image::Manifest]?,
        metadata: DockerEngineRuby::Image::Metadata,
        os: String,
        os_version: String?,
        repo_digests: ::Array[String],
        repo_tags: ::Array[String],
        root_fs: DockerEngineRuby::Image::RootFs,
        size: Integer,
        variant: String?
      }

    class Image < DockerEngineRuby::Internal::Type::BaseModel
      attr_reader architecture: String?

      def architecture=: (String) -> String

      attr_accessor author: String?

      attr_accessor comment: String?

      attr_reader config: DockerEngineRuby::Image::Config?

      def config=: (
        DockerEngineRuby::Image::Config
      ) -> DockerEngineRuby::Image::Config

      attr_accessor created: Time?

      attr_accessor descriptor: DockerEngineRuby::Image::Descriptor?

      attr_accessor graph_driver: DockerEngineRuby::Image::GraphDriver?

      attr_reader id: String?

      def id=: (String) -> String

      attr_accessor identity: DockerEngineRuby::Image::Identity?

      attr_accessor manifests: ::Array[DockerEngineRuby::Image::Manifest]?

      attr_reader metadata: DockerEngineRuby::Image::Metadata?

      def metadata=: (
        DockerEngineRuby::Image::Metadata
      ) -> DockerEngineRuby::Image::Metadata

      attr_reader os: String?

      def os=: (String) -> String

      attr_accessor os_version: String?

      attr_reader repo_digests: ::Array[String]?

      def repo_digests=: (::Array[String]) -> ::Array[String]

      attr_reader repo_tags: ::Array[String]?

      def repo_tags=: (::Array[String]) -> ::Array[String]

      attr_reader root_fs: DockerEngineRuby::Image::RootFs?

      def root_fs=: (
        DockerEngineRuby::Image::RootFs
      ) -> DockerEngineRuby::Image::RootFs

      attr_reader size: Integer?

      def size=: (Integer) -> Integer

      attr_accessor variant: String?

      def initialize: (
        ?architecture: String,
        ?author: String?,
        ?comment: String?,
        ?config: DockerEngineRuby::Image::Config,
        ?created: Time?,
        ?descriptor: DockerEngineRuby::Image::Descriptor?,
        ?graph_driver: DockerEngineRuby::Image::GraphDriver?,
        ?id: String,
        ?identity: DockerEngineRuby::Image::Identity?,
        ?manifests: ::Array[DockerEngineRuby::Image::Manifest]?,
        ?metadata: DockerEngineRuby::Image::Metadata,
        ?os: String,
        ?os_version: String?,
        ?repo_digests: ::Array[String],
        ?repo_tags: ::Array[String],
        ?root_fs: DockerEngineRuby::Image::RootFs,
        ?size: Integer,
        ?variant: String?
      ) -> void

      def to_hash: -> {
        architecture: String,
        author: String?,
        comment: String?,
        config: DockerEngineRuby::Image::Config,
        created: Time?,
        descriptor: DockerEngineRuby::Image::Descriptor?,
        graph_driver: DockerEngineRuby::Image::GraphDriver?,
        id: String,
        identity: DockerEngineRuby::Image::Identity?,
        manifests: ::Array[DockerEngineRuby::Image::Manifest]?,
        metadata: DockerEngineRuby::Image::Metadata,
        os: String,
        os_version: String?,
        repo_digests: ::Array[String],
        repo_tags: ::Array[String],
        root_fs: DockerEngineRuby::Image::RootFs,
        size: Integer,
        variant: String?
      }

      type config =
        {
          args_escaped: bool?,
          cmd: ::Array[String],
          entrypoint: ::Array[String],
          env: ::Array[String],
          exposed_ports: ::Hash[Symbol, ::Hash[Symbol, top]]?,
          healthcheck: DockerEngineRuby::Image::Config::Healthcheck,
          labels: ::Hash[Symbol, String],
          on_build: ::Array[String]?,
          shell: ::Array[String]?,
          stop_signal: String?,
          user: String,
          volumes: ::Hash[Symbol, ::Hash[Symbol, top]],
          working_dir: String
        }

      class Config < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor args_escaped: bool?

        attr_reader cmd: ::Array[String]?

        def cmd=: (::Array[String]) -> ::Array[String]

        attr_reader entrypoint: ::Array[String]?

        def entrypoint=: (::Array[String]) -> ::Array[String]

        attr_reader env: ::Array[String]?

        def env=: (::Array[String]) -> ::Array[String]

        attr_accessor exposed_ports: ::Hash[Symbol, ::Hash[Symbol, top]]?

        attr_reader healthcheck: DockerEngineRuby::Image::Config::Healthcheck?

        def healthcheck=: (
          DockerEngineRuby::Image::Config::Healthcheck
        ) -> DockerEngineRuby::Image::Config::Healthcheck

        attr_reader labels: ::Hash[Symbol, String]?

        def labels=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

        attr_accessor on_build: ::Array[String]?

        attr_accessor shell: ::Array[String]?

        attr_accessor stop_signal: String?

        attr_reader user: String?

        def user=: (String) -> String

        attr_reader volumes: ::Hash[Symbol, ::Hash[Symbol, top]]?

        def volumes=: (
          ::Hash[Symbol, ::Hash[Symbol, top]]
        ) -> ::Hash[Symbol, ::Hash[Symbol, top]]

        attr_reader working_dir: String?

        def working_dir=: (String) -> String

        def initialize: (
          ?args_escaped: bool?,
          ?cmd: ::Array[String],
          ?entrypoint: ::Array[String],
          ?env: ::Array[String],
          ?exposed_ports: ::Hash[Symbol, ::Hash[Symbol, top]]?,
          ?healthcheck: DockerEngineRuby::Image::Config::Healthcheck,
          ?labels: ::Hash[Symbol, String],
          ?on_build: ::Array[String]?,
          ?shell: ::Array[String]?,
          ?stop_signal: String?,
          ?user: String,
          ?volumes: ::Hash[Symbol, ::Hash[Symbol, top]],
          ?working_dir: String
        ) -> void

        def to_hash: -> {
          args_escaped: bool?,
          cmd: ::Array[String],
          entrypoint: ::Array[String],
          env: ::Array[String],
          exposed_ports: ::Hash[Symbol, ::Hash[Symbol, top]]?,
          healthcheck: DockerEngineRuby::Image::Config::Healthcheck,
          labels: ::Hash[Symbol, String],
          on_build: ::Array[String]?,
          shell: ::Array[String]?,
          stop_signal: String?,
          user: String,
          volumes: ::Hash[Symbol, ::Hash[Symbol, top]],
          working_dir: String
        }

        type healthcheck =
          {
            interval: Integer,
            retries: Integer,
            start_interval: Integer,
            start_period: Integer,
            test_: ::Array[String],
            timeout: Integer
          }

        class Healthcheck < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader interval: Integer?

          def interval=: (Integer) -> Integer

          attr_reader retries: Integer?

          def retries=: (Integer) -> Integer

          attr_reader start_interval: Integer?

          def start_interval=: (Integer) -> Integer

          attr_reader start_period: Integer?

          def start_period=: (Integer) -> Integer

          attr_reader test_: ::Array[String]?

          def test_=: (::Array[String]) -> ::Array[String]

          attr_reader timeout: Integer?

          def timeout=: (Integer) -> Integer

          def initialize: (
            ?interval: Integer,
            ?retries: Integer,
            ?start_interval: Integer,
            ?start_period: Integer,
            ?test_: ::Array[String],
            ?timeout: Integer
          ) -> void

          def to_hash: -> {
            interval: Integer,
            retries: Integer,
            start_interval: Integer,
            start_period: Integer,
            test_: ::Array[String],
            timeout: Integer
          }
        end
      end

      type descriptor =
        {
          annotations: ::Hash[Symbol, String]?,
          artifact_type: String?,
          data: String?,
          digest: String,
          media_type: String,
          platform: DockerEngineRuby::Image::Descriptor::Platform,
          size: Integer,
          urls: ::Array[String]?
        }

      class Descriptor < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor annotations: ::Hash[Symbol, String]?

        attr_accessor artifact_type: String?

        attr_accessor data: String?

        attr_reader digest: String?

        def digest=: (String) -> String

        attr_reader media_type: String?

        def media_type=: (String) -> String

        attr_reader platform: DockerEngineRuby::Image::Descriptor::Platform?

        def platform=: (
          DockerEngineRuby::Image::Descriptor::Platform
        ) -> DockerEngineRuby::Image::Descriptor::Platform

        attr_reader size: Integer?

        def size=: (Integer) -> Integer

        attr_accessor urls: ::Array[String]?

        def initialize: (
          ?annotations: ::Hash[Symbol, String]?,
          ?artifact_type: String?,
          ?data: String?,
          ?digest: String,
          ?media_type: String,
          ?platform: DockerEngineRuby::Image::Descriptor::Platform,
          ?size: Integer,
          ?urls: ::Array[String]?
        ) -> void

        def to_hash: -> {
          annotations: ::Hash[Symbol, String]?,
          artifact_type: String?,
          data: String?,
          digest: String,
          media_type: String,
          platform: DockerEngineRuby::Image::Descriptor::Platform,
          size: Integer,
          urls: ::Array[String]?
        }

        type platform =
          {
            architecture: String,
            os: String,
            os_features: ::Array[String],
            os_version: String,
            variant: String
          }

        class Platform < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader architecture: String?

          def architecture=: (String) -> String

          attr_reader os: String?

          def os=: (String) -> String

          attr_reader os_features: ::Array[String]?

          def os_features=: (::Array[String]) -> ::Array[String]

          attr_reader os_version: String?

          def os_version=: (String) -> String

          attr_reader variant: String?

          def variant=: (String) -> String

          def initialize: (
            ?architecture: String,
            ?os: String,
            ?os_features: ::Array[String],
            ?os_version: String,
            ?variant: String
          ) -> void

          def to_hash: -> {
            architecture: String,
            os: String,
            os_features: ::Array[String],
            os_version: String,
            variant: String
          }
        end
      end

      type graph_driver = { data: ::Hash[Symbol, String], name: String }

      class GraphDriver < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor data: ::Hash[Symbol, String]

        attr_accessor name: String

        def initialize: (data: ::Hash[Symbol, String], name: String) -> void

        def to_hash: -> { data: ::Hash[Symbol, String], name: String }
      end

      type identity =
        {
          build: ::Array[DockerEngineRuby::Image::Identity::Build],
          pull: ::Array[DockerEngineRuby::Image::Identity::Pull],
          signature: ::Array[DockerEngineRuby::Image::Identity::Signature]
        }

      class Identity < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader build: ::Array[DockerEngineRuby::Image::Identity::Build]?

        def build=: (
          ::Array[DockerEngineRuby::Image::Identity::Build]
        ) -> ::Array[DockerEngineRuby::Image::Identity::Build]

        attr_reader pull: ::Array[DockerEngineRuby::Image::Identity::Pull]?

        def pull=: (
          ::Array[DockerEngineRuby::Image::Identity::Pull]
        ) -> ::Array[DockerEngineRuby::Image::Identity::Pull]

        attr_reader signature: ::Array[DockerEngineRuby::Image::Identity::Signature]?

        def signature=: (
          ::Array[DockerEngineRuby::Image::Identity::Signature]
        ) -> ::Array[DockerEngineRuby::Image::Identity::Signature]

        def initialize: (
          ?build: ::Array[DockerEngineRuby::Image::Identity::Build],
          ?pull: ::Array[DockerEngineRuby::Image::Identity::Pull],
          ?signature: ::Array[DockerEngineRuby::Image::Identity::Signature]
        ) -> void

        def to_hash: -> {
          build: ::Array[DockerEngineRuby::Image::Identity::Build],
          pull: ::Array[DockerEngineRuby::Image::Identity::Pull],
          signature: ::Array[DockerEngineRuby::Image::Identity::Signature]
        }

        type build = { created_at: Time, ref: String }

        class Build < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader created_at: Time?

          def created_at=: (Time) -> Time

          attr_reader ref: String?

          def ref=: (String) -> String

          def initialize: (?created_at: Time, ?ref: String) -> void

          def to_hash: -> { created_at: Time, ref: String }
        end

        type pull = { repository: String }

        class Pull < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader repository: String?

          def repository=: (String) -> String

          def initialize: (?repository: String) -> void

          def to_hash: -> { repository: String }
        end

        type signature =
          {
            docker_reference: String,
            error: String,
            known_signer: DockerEngineRuby::Models::Image::Identity::Signature::known_signer,
            name: String,
            signature_type: DockerEngineRuby::Models::Image::Identity::Signature::signature_type,
            signer: DockerEngineRuby::Image::Identity::Signature::Signer,
            timestamps: ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp],
            warnings: ::Array[String]
          }

        class Signature < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader docker_reference: String?

          def docker_reference=: (String) -> String

          attr_reader error: String?

          def error=: (String) -> String

          attr_reader known_signer: DockerEngineRuby::Models::Image::Identity::Signature::known_signer?

          def known_signer=: (
            DockerEngineRuby::Models::Image::Identity::Signature::known_signer
          ) -> DockerEngineRuby::Models::Image::Identity::Signature::known_signer

          attr_reader name: String?

          def name=: (String) -> String

          attr_reader signature_type: DockerEngineRuby::Models::Image::Identity::Signature::signature_type?

          def signature_type=: (
            DockerEngineRuby::Models::Image::Identity::Signature::signature_type
          ) -> DockerEngineRuby::Models::Image::Identity::Signature::signature_type

          attr_reader signer: DockerEngineRuby::Image::Identity::Signature::Signer?

          def signer=: (
            DockerEngineRuby::Image::Identity::Signature::Signer
          ) -> DockerEngineRuby::Image::Identity::Signature::Signer

          attr_reader timestamps: ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp]?

          def timestamps=: (
            ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp]
          ) -> ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp]

          attr_reader warnings: ::Array[String]?

          def warnings=: (::Array[String]) -> ::Array[String]

          def initialize: (
            ?docker_reference: String,
            ?error: String,
            ?known_signer: DockerEngineRuby::Models::Image::Identity::Signature::known_signer,
            ?name: String,
            ?signature_type: DockerEngineRuby::Models::Image::Identity::Signature::signature_type,
            ?signer: DockerEngineRuby::Image::Identity::Signature::Signer,
            ?timestamps: ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp],
            ?warnings: ::Array[String]
          ) -> void

          def to_hash: -> {
            docker_reference: String,
            error: String,
            known_signer: DockerEngineRuby::Models::Image::Identity::Signature::known_signer,
            name: String,
            signature_type: DockerEngineRuby::Models::Image::Identity::Signature::signature_type,
            signer: DockerEngineRuby::Image::Identity::Signature::Signer,
            timestamps: ::Array[DockerEngineRuby::Image::Identity::Signature::Timestamp],
            warnings: ::Array[String]
          }

          type known_signer = :DHI

          module KnownSigner
            extend DockerEngineRuby::Internal::Type::Enum

            DHI: :DHI

            def self?.values: -> ::Array[DockerEngineRuby::Models::Image::Identity::Signature::known_signer]
          end

          type signature_type = :"bundle-v0.3" | :"simplesigning-v1"

          module SignatureType
            extend DockerEngineRuby::Internal::Type::Enum

            BUNDLE_V0_3: :"bundle-v0.3"
            SIMPLESIGNING_V1: :"simplesigning-v1"

            def self?.values: -> ::Array[DockerEngineRuby::Models::Image::Identity::Signature::signature_type]
          end

          type signer =
            {
              build_config_digest: String,
              build_config_uri: String,
              build_signer_digest: String,
              build_signer_uri: String,
              build_trigger: String,
              certificate_issuer: String,
              issuer: String,
              run_invocation_uri: String,
              runner_environment: String,
              source_repository_digest: String,
              source_repository_identifier: String,
              source_repository_owner_identifier: String,
              source_repository_owner_uri: String,
              source_repository_ref: String,
              source_repository_uri: String,
              source_repository_visibility_at_signing: String,
              subject_alternative_name: String
            }

          class Signer < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader build_config_digest: String?

            def build_config_digest=: (String) -> String

            attr_reader build_config_uri: String?

            def build_config_uri=: (String) -> String

            attr_reader build_signer_digest: String?

            def build_signer_digest=: (String) -> String

            attr_reader build_signer_uri: String?

            def build_signer_uri=: (String) -> String

            attr_reader build_trigger: String?

            def build_trigger=: (String) -> String

            attr_reader certificate_issuer: String?

            def certificate_issuer=: (String) -> String

            attr_reader issuer: String?

            def issuer=: (String) -> String

            attr_reader run_invocation_uri: String?

            def run_invocation_uri=: (String) -> String

            attr_reader runner_environment: String?

            def runner_environment=: (String) -> String

            attr_reader source_repository_digest: String?

            def source_repository_digest=: (String) -> String

            attr_reader source_repository_identifier: String?

            def source_repository_identifier=: (String) -> String

            attr_reader source_repository_owner_identifier: String?

            def source_repository_owner_identifier=: (String) -> String

            attr_reader source_repository_owner_uri: String?

            def source_repository_owner_uri=: (String) -> String

            attr_reader source_repository_ref: String?

            def source_repository_ref=: (String) -> String

            attr_reader source_repository_uri: String?

            def source_repository_uri=: (String) -> String

            attr_reader source_repository_visibility_at_signing: String?

            def source_repository_visibility_at_signing=: (String) -> String

            attr_reader subject_alternative_name: String?

            def subject_alternative_name=: (String) -> String

            def initialize: (
              ?build_config_digest: String,
              ?build_config_uri: String,
              ?build_signer_digest: String,
              ?build_signer_uri: String,
              ?build_trigger: String,
              ?certificate_issuer: String,
              ?issuer: String,
              ?run_invocation_uri: String,
              ?runner_environment: String,
              ?source_repository_digest: String,
              ?source_repository_identifier: String,
              ?source_repository_owner_identifier: String,
              ?source_repository_owner_uri: String,
              ?source_repository_ref: String,
              ?source_repository_uri: String,
              ?source_repository_visibility_at_signing: String,
              ?subject_alternative_name: String
            ) -> void

            def to_hash: -> {
              build_config_digest: String,
              build_config_uri: String,
              build_signer_digest: String,
              build_signer_uri: String,
              build_trigger: String,
              certificate_issuer: String,
              issuer: String,
              run_invocation_uri: String,
              runner_environment: String,
              source_repository_digest: String,
              source_repository_identifier: String,
              source_repository_owner_identifier: String,
              source_repository_owner_uri: String,
              source_repository_ref: String,
              source_repository_uri: String,
              source_repository_visibility_at_signing: String,
              subject_alternative_name: String
            }
          end

          type timestamp =
            {
              timestamp: Time,
              type: DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_,
              uri: String
            }

          class Timestamp < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader timestamp: Time?

            def timestamp=: (Time) -> Time

            attr_reader type: DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_?

            def type=: (
              DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_
            ) -> DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_

            attr_reader uri: String?

            def uri=: (String) -> String

            def initialize: (
              ?timestamp: Time,
              ?type: DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_,
              ?uri: String
            ) -> void

            def to_hash: -> {
              timestamp: Time,
              type: DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_,
              uri: String
            }

            type type_ = :Tlog | :TimestampAuthority

            module Type
              extend DockerEngineRuby::Internal::Type::Enum

              TLOG: :Tlog
              TIMESTAMP_AUTHORITY: :TimestampAuthority

              def self?.values: -> ::Array[DockerEngineRuby::Models::Image::Identity::Signature::Timestamp::type_]
            end
          end
        end
      end

      type manifest =
        {
          available: bool,
          descriptor: DockerEngineRuby::Image::Manifest::Descriptor,
          id: String,
          kind: DockerEngineRuby::Models::Image::Manifest::kind,
          size: DockerEngineRuby::Image::Manifest::Size,
          attestation_data: DockerEngineRuby::Image::Manifest::AttestationData?,
          image_data: DockerEngineRuby::Image::Manifest::ImageData?
        }

      class Manifest < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor available: bool

        attr_accessor descriptor: DockerEngineRuby::Image::Manifest::Descriptor

        attr_accessor id: String

        attr_accessor kind: DockerEngineRuby::Models::Image::Manifest::kind

        attr_accessor size: DockerEngineRuby::Image::Manifest::Size

        attr_accessor attestation_data: DockerEngineRuby::Image::Manifest::AttestationData?

        attr_accessor image_data: DockerEngineRuby::Image::Manifest::ImageData?

        def initialize: (
          available: bool,
          descriptor: DockerEngineRuby::Image::Manifest::Descriptor,
          id: String,
          kind: DockerEngineRuby::Models::Image::Manifest::kind,
          size: DockerEngineRuby::Image::Manifest::Size,
          ?attestation_data: DockerEngineRuby::Image::Manifest::AttestationData?,
          ?image_data: DockerEngineRuby::Image::Manifest::ImageData?
        ) -> void

        def to_hash: -> {
          available: bool,
          descriptor: DockerEngineRuby::Image::Manifest::Descriptor,
          id: String,
          kind: DockerEngineRuby::Models::Image::Manifest::kind,
          size: DockerEngineRuby::Image::Manifest::Size,
          attestation_data: DockerEngineRuby::Image::Manifest::AttestationData?,
          image_data: DockerEngineRuby::Image::Manifest::ImageData?
        }

        type descriptor =
          {
            annotations: ::Hash[Symbol, String]?,
            artifact_type: String?,
            data: String?,
            digest: String,
            media_type: String,
            platform: DockerEngineRuby::Image::Manifest::Descriptor::Platform,
            size: Integer,
            urls: ::Array[String]?
          }

        class Descriptor < DockerEngineRuby::Internal::Type::BaseModel
          attr_accessor annotations: ::Hash[Symbol, String]?

          attr_accessor artifact_type: String?

          attr_accessor data: String?

          attr_reader digest: String?

          def digest=: (String) -> String

          attr_reader media_type: String?

          def media_type=: (String) -> String

          attr_reader platform: DockerEngineRuby::Image::Manifest::Descriptor::Platform?

          def platform=: (
            DockerEngineRuby::Image::Manifest::Descriptor::Platform
          ) -> DockerEngineRuby::Image::Manifest::Descriptor::Platform

          attr_reader size: Integer?

          def size=: (Integer) -> Integer

          attr_accessor urls: ::Array[String]?

          def initialize: (
            ?annotations: ::Hash[Symbol, String]?,
            ?artifact_type: String?,
            ?data: String?,
            ?digest: String,
            ?media_type: String,
            ?platform: DockerEngineRuby::Image::Manifest::Descriptor::Platform,
            ?size: Integer,
            ?urls: ::Array[String]?
          ) -> void

          def to_hash: -> {
            annotations: ::Hash[Symbol, String]?,
            artifact_type: String?,
            data: String?,
            digest: String,
            media_type: String,
            platform: DockerEngineRuby::Image::Manifest::Descriptor::Platform,
            size: Integer,
            urls: ::Array[String]?
          }

          type platform =
            {
              architecture: String,
              os: String,
              os_features: ::Array[String],
              os_version: String,
              variant: String
            }

          class Platform < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader architecture: String?

            def architecture=: (String) -> String

            attr_reader os: String?

            def os=: (String) -> String

            attr_reader os_features: ::Array[String]?

            def os_features=: (::Array[String]) -> ::Array[String]

            attr_reader os_version: String?

            def os_version=: (String) -> String

            attr_reader variant: String?

            def variant=: (String) -> String

            def initialize: (
              ?architecture: String,
              ?os: String,
              ?os_features: ::Array[String],
              ?os_version: String,
              ?variant: String
            ) -> void

            def to_hash: -> {
              architecture: String,
              os: String,
              os_features: ::Array[String],
              os_version: String,
              variant: String
            }
          end
        end

        type kind = :image | :attestation | :unknown

        module Kind
          extend DockerEngineRuby::Internal::Type::Enum

          IMAGE: :image
          ATTESTATION: :attestation
          UNKNOWN: :unknown

          def self?.values: -> ::Array[DockerEngineRuby::Models::Image::Manifest::kind]
        end

        type size = { content: Integer, total: Integer }

        class Size < DockerEngineRuby::Internal::Type::BaseModel
          attr_accessor content: Integer

          attr_accessor total: Integer

          def initialize: (content: Integer, total: Integer) -> void

          def to_hash: -> { content: Integer, total: Integer }
        end

        type attestation_data = { for_: String }

        class AttestationData < DockerEngineRuby::Internal::Type::BaseModel
          attr_accessor for_: String

          def initialize: (for_: String) -> void

          def to_hash: -> { for_: String }
        end

        type image_data =
          {
            containers: ::Array[String],
            platform: DockerEngineRuby::Image::Manifest::ImageData::Platform,
            size: DockerEngineRuby::Image::Manifest::ImageData::Size
          }

        class ImageData < DockerEngineRuby::Internal::Type::BaseModel
          attr_accessor containers: ::Array[String]

          attr_accessor platform: DockerEngineRuby::Image::Manifest::ImageData::Platform

          attr_accessor size: DockerEngineRuby::Image::Manifest::ImageData::Size

          def initialize: (
            containers: ::Array[String],
            platform: DockerEngineRuby::Image::Manifest::ImageData::Platform,
            size: DockerEngineRuby::Image::Manifest::ImageData::Size
          ) -> void

          def to_hash: -> {
            containers: ::Array[String],
            platform: DockerEngineRuby::Image::Manifest::ImageData::Platform,
            size: DockerEngineRuby::Image::Manifest::ImageData::Size
          }

          type platform =
            {
              architecture: String,
              os: String,
              os_features: ::Array[String],
              os_version: String,
              variant: String
            }

          class Platform < DockerEngineRuby::Internal::Type::BaseModel
            attr_reader architecture: String?

            def architecture=: (String) -> String

            attr_reader os: String?

            def os=: (String) -> String

            attr_reader os_features: ::Array[String]?

            def os_features=: (::Array[String]) -> ::Array[String]

            attr_reader os_version: String?

            def os_version=: (String) -> String

            attr_reader variant: String?

            def variant=: (String) -> String

            def initialize: (
              ?architecture: String,
              ?os: String,
              ?os_features: ::Array[String],
              ?os_version: String,
              ?variant: String
            ) -> void

            def to_hash: -> {
              architecture: String,
              os: String,
              os_features: ::Array[String],
              os_version: String,
              variant: String
            }
          end

          type size = { unpacked: Integer }

          class Size < DockerEngineRuby::Internal::Type::BaseModel
            attr_accessor unpacked: Integer

            def initialize: (unpacked: Integer) -> void

            def to_hash: -> { unpacked: Integer }
          end
        end
      end

      type metadata = { last_tag_time: Time? }

      class Metadata < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor last_tag_time: Time?

        def initialize: (?last_tag_time: Time?) -> void

        def to_hash: -> { last_tag_time: Time? }
      end

      type root_fs = { type: String, layers: ::Array[String] }

      class RootFs < DockerEngineRuby::Internal::Type::BaseModel
        attr_accessor type: String

        attr_reader layers: ::Array[String]?

        def layers=: (::Array[String]) -> ::Array[String]

        def initialize: (type: String, ?layers: ::Array[String]) -> void

        def to_hash: -> { type: String, layers: ::Array[String] }
      end
    end
  end
end
