module DockerEngineRuby
  module Models
    type network =
      {
        attachable: bool,
        config_from: DockerEngineRuby::Network::ConfigFrom,
        config_only: bool,
        created: Time,
        driver: String,
        :enable_i_pv4 => bool,
        :enable_i_pv6 => bool,
        id: String,
        ingress: bool,
        internal: bool,
        ipam: DockerEngineRuby::Network::Ipam,
        labels: top,
        name: String,
        options: top,
        peers: ::Array[DockerEngineRuby::Network::Peer],
        scope: String
      }

    class Network < DockerEngineRuby::Internal::Type::BaseModel
      attr_reader attachable: bool?

      def attachable=: (bool) -> bool

      attr_reader config_from: DockerEngineRuby::Network::ConfigFrom?

      def config_from=: (
        DockerEngineRuby::Network::ConfigFrom
      ) -> DockerEngineRuby::Network::ConfigFrom

      attr_reader config_only: bool?

      def config_only=: (bool) -> bool

      attr_reader created: Time?

      def created=: (Time) -> Time

      attr_reader driver: String?

      def driver=: (String) -> String

      attr_reader enable_i_pv4: bool?

      def enable_i_pv4=: (bool) -> bool

      attr_reader enable_i_pv6: bool?

      def enable_i_pv6=: (bool) -> bool

      attr_reader id: String?

      def id=: (String) -> String

      attr_reader ingress: bool?

      def ingress=: (bool) -> bool

      attr_reader internal: bool?

      def internal=: (bool) -> bool

      attr_reader ipam: DockerEngineRuby::Network::Ipam?

      def ipam=: (
        DockerEngineRuby::Network::Ipam
      ) -> DockerEngineRuby::Network::Ipam

      attr_reader labels: top?

      def labels=: (top) -> top

      attr_reader name: String?

      def name=: (String) -> String

      attr_reader options: top?

      def options=: (top) -> top

      attr_reader peers: ::Array[DockerEngineRuby::Network::Peer]?

      def peers=: (
        ::Array[DockerEngineRuby::Network::Peer]
      ) -> ::Array[DockerEngineRuby::Network::Peer]

      attr_reader scope: String?

      def scope=: (String) -> String

      def initialize: (
        ?attachable: bool,
        ?config_from: DockerEngineRuby::Network::ConfigFrom,
        ?config_only: bool,
        ?created: Time,
        ?driver: String,
        ?enable_i_pv4: bool,
        ?enable_i_pv6: bool,
        ?id: String,
        ?ingress: bool,
        ?internal: bool,
        ?ipam: DockerEngineRuby::Network::Ipam,
        ?labels: top,
        ?name: String,
        ?options: top,
        ?peers: ::Array[DockerEngineRuby::Network::Peer],
        ?scope: String
      ) -> void

      def to_hash: -> {
        attachable: bool,
        config_from: DockerEngineRuby::Network::ConfigFrom,
        config_only: bool,
        created: Time,
        driver: String,
        :enable_i_pv4 => bool,
        :enable_i_pv6 => bool,
        id: String,
        ingress: bool,
        internal: bool,
        ipam: DockerEngineRuby::Network::Ipam,
        labels: top,
        name: String,
        options: top,
        peers: ::Array[DockerEngineRuby::Network::Peer],
        scope: String
      }

      type config_from = { network: String }

      class ConfigFrom < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader network: String?

        def network=: (String) -> String

        def initialize: (?network: String) -> void

        def to_hash: -> { network: String }
      end

      type ipam =
        {
          config: ::Array[DockerEngineRuby::Network::Ipam::Config],
          driver: String,
          options: top
        }

      class Ipam < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader config: ::Array[DockerEngineRuby::Network::Ipam::Config]?

        def config=: (
          ::Array[DockerEngineRuby::Network::Ipam::Config]
        ) -> ::Array[DockerEngineRuby::Network::Ipam::Config]

        attr_reader driver: String?

        def driver=: (String) -> String

        attr_reader options: top?

        def options=: (top) -> top

        def initialize: (
          ?config: ::Array[DockerEngineRuby::Network::Ipam::Config],
          ?driver: String,
          ?options: top
        ) -> void

        def to_hash: -> {
          config: ::Array[DockerEngineRuby::Network::Ipam::Config],
          driver: String,
          options: top
        }

        type config =
          {
            auxiliary_addresses: top,
            gateway: String,
            ip_range: String,
            subnet: String
          }

        class Config < DockerEngineRuby::Internal::Type::BaseModel
          attr_reader auxiliary_addresses: top?

          def auxiliary_addresses=: (top) -> top

          attr_reader gateway: String?

          def gateway=: (String) -> String

          attr_reader ip_range: String?

          def ip_range=: (String) -> String

          attr_reader subnet: String?

          def subnet=: (String) -> String

          def initialize: (
            ?auxiliary_addresses: top,
            ?gateway: String,
            ?ip_range: String,
            ?subnet: String
          ) -> void

          def to_hash: -> {
            auxiliary_addresses: top,
            gateway: String,
            ip_range: String,
            subnet: String
          }
        end
      end

      type peer = { ip: String, name: String }

      class Peer < DockerEngineRuby::Internal::Type::BaseModel
        attr_reader ip: String?

        def ip=: (String) -> String

        attr_reader name: String?

        def name=: (String) -> String

        def initialize: (?ip: String, ?name: String) -> void

        def to_hash: -> { ip: String, name: String }
      end
    end
  end
end
